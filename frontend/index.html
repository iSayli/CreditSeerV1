<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CreditSeer - Credit Agreement Analyzer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Archivo:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <!-- PAGE 1: HOME -->
    <div class="page upload-page active" id="uploadPage">
        <!-- Header -->
        <header class="home-header">
            <div class="home-logo" style="cursor: pointer;" onclick="showPage('uploadPage')">
                <img src="CreditSeerLogo.svg" alt="CreditSeer" class="home-logo-img">
            </div>
            <nav class="home-nav">
                <a href="#about">About</a>
                <a href="#contact">Contact</a>
            </nav>
        </header>

        <!-- Hero Section -->
        <section class="home-hero">
            <h1>Turn credit agreements into structured, analysis-ready insights.</h1>
            <p>Upload a credit agreement and instantly surface key economic and risk terms in a standardized review dashboard.</p>
        </section>

        <!-- Upload Card -->
        <div class="upload-card">
            <div class="upload-card-inner">
            <div class="upload-area" id="uploadArea">
                    <div class="upload-icon">
                        <span class="material-icons">cloud_upload</span>
                    </div>
                    <div class="upload-text">Click to upload or drag and drop</div>
                    <div class="upload-hint">PDF (max)</div>
            </div>
            <input type="file" id="fileInput" accept=".pdf" />
                
                <!-- File Upload Item -->
                <div class="file-upload-item" id="fileUploadItem">
                    <div class="file-icon">
                        <span class="material-icons">picture_as_pdf</span>
        </div>
                    <div class="file-info">
                        <div class="file-name" id="fileName">Credit Agreement.pdf</div>
                        <div class="file-size" id="fileSize">200 KB – 100% uploaded</div>
                    </div>
                    <div class="file-actions">
                        <div class="file-check">
                            <span class="material-icons">check</span>
                        </div>
                        <button class="file-delete" id="fileDeleteBtn" title="Delete file">
                            <span class="material-icons">delete</span>
                        </button>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div class="upload-actions">
                    <button class="btn-secondary" id="viewSampleBtn">
                        <span class="material-icons">visibility</span>
                        View Sample Dashboard
                    </button>
                    <button class="btn-primary" id="launchDashboardBtn" disabled>
                        Launch Review Dashboard
                        <span class="material-icons">arrow_forward</span>
                    </button>
                </div>
            </div>
        </div>

        <!-- Features Section -->
        <section class="home-features">
            <div class="features-grid">
                <div class="feature-card">
                    <div class="feature-icon">
                        <span class="material-icons">article</span>
                    </div>
                    <div class="feature-title">Standardized Agreement Structuring</div>
                    <div class="feature-description">Key values are presented in a LSTA-aligned review dashboard.</div>
                </div>
                <div class="feature-card">
                    <div class="feature-icon">
                        <span class="material-icons">find_in_page</span>
                    </div>
                    <div class="feature-title">Source-Verified Outputs</div>
                    <div class="feature-description">Each LLM-extracted value is anchored to the governing agreement text.</div>
                </div>
                <div class="feature-card">
                    <div class="feature-icon">
                        <span class="material-icons">edit_note</span>
                    </div>
                    <div class="feature-title">Review & Annotate Values</div>
                    <div class="feature-description">Edits are captured with rationale to support review and improvements.</div>
                </div>
            </div>
        </section>

        <!-- Footer -->
        <footer class="home-footer">
            <div>©CreditSeer</div>
            <div class="home-footer-links">
                <a href="#privacy">Privacy</a>
                <span class="separator">·</span>
                <a href="#terms">Terms</a>
            </div>
        </footer>
    </div>

    <!-- PAGE 2: PROGRESS -->
    <div class="page progress-page" id="progressPage">
        <!-- Header -->
        <header class="home-header">
            <div class="home-logo" style="cursor: pointer;" onclick="showPage('uploadPage')">
                <img src="CreditSeerLogo.svg" alt="CreditSeer" class="home-logo-img">
            </div>
            <nav class="home-nav">
                <a href="#about">About</a>
                <a href="#contact">Contact</a>
            </nav>
        </header>
        <div class="progress-container">
            <h2>Reviewing Credit Agreement</h2>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            <div class="progress-status" id="progressStatus">Initializing...</div>
            <div class="progress-steps" id="progressSteps"></div>
        </div>
    </div>

    <!-- PAGE 3: DASHBOARD -->
    <div class="page dashboard-page" id="dashboardPage">
        <!-- Header -->
        <header class="home-header">
            <div class="home-logo" style="cursor: pointer;" onclick="showPage('uploadPage')">
                <img src="CreditSeerLogo.svg" alt="CreditSeer" class="home-logo-img">
            </div>
            <nav class="home-nav">
                <a href="#about">About</a>
                <a href="#contact">Contact</a>
            </nav>
        </header>
        <!-- Toolbar -->
        <div class="toolbar">
            <div class="toolbar-left">
                <button class="back-button" id="backIcon" title="Go Back">
                    <span class="material-symbols-outlined">keyboard_backspace</span>
                    Back
                </button>
                <div class="toolbar-file-name" id="toolbarFileName">No file loaded</div>
            </div>
            <div class="toolbar-right">
                <button class="export-report-button" id="exportIcon" title="Export Report">
                    Export Report
                    <span class="material-symbols-outlined">file_export</span>
                </button>
            </div>
        </div>

        <!-- Main Layout -->
        <div class="dashboard-layout">
            <!-- Left: Main Dashboard (70%) -->
            <div class="dashboard-main" id="dashboardMain">
                <!-- Content will be dynamically generated -->
            </div>

            <!-- Right: Value Details Panel (30%) -->
            <div class="value-details-panel">
                <!-- More Details Section with Expandable Header -->
                <div class="expandable-section" id="moreDetailsSection">
                    <!-- Heading -->
                    <div class="value-details-heading" id="valueDetailsHeading" style="display: flex; justify-content: space-between; align-items: flex-start; gap: 8px; padding: 8px 24px; margin-top: 12px; margin-bottom: 0px;">
                        <span style="font-size: 16px;">Value Label</span>
                    </div>
                    <div class="expandable-section-header" id="moreDetailsHeader">
                        <span class="expandable-section-title">More Details</span>
                        <span class="expand-icon material-symbols-outlined" id="moreDetailsExpandIcon">expand_content</span>
                    </div>
                    <div class="expandable-section-content" id="moreDetailsContent" style="gap: 0px; padding-top: 12px;">
                        <div id="moreDetailsEmpty" style="color: var(--grey-500); font-size: 0.9em; text-align: center; padding: 40px 20px; display: none;">
                            Click on any extracted value in the dashboard to view and edit details
                        </div>
                        
                        <!-- Descriptor -->
                        <div class="value-details-descriptor" id="valueDetailsDescriptor" style="padding: 0px 24px; display: block; margin-bottom: 16px;"></div>
                        
                        <!-- Value and Revert Button -->
                        <div id="valueDisplayContainer" style="margin: 0px; display: flex; flex-direction: column; padding: 0px 24px;">
                            <div style="margin-bottom: 0px; font-weight: 800; color: var(--grey-400); font-size: 12px;">Value:</div>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <div style="font-size: 1.1em; font-weight: 600; color: var(--teal); margin-bottom: 0px;" id="valueDisplay"></div>
                                <button class="modify-button" id="modifyButton" style="display: inline-flex; align-items: center; justify-content: center; padding: 0; background: none; border: none; cursor: pointer; color: var(--teal);">
                                    <span class="material-icons" style="font-size: 1.2em;">edit</span>
                                </button>
                            </div>
                            <!-- Modification History (shown when overridden) -->
                            <div id="modificationHistory" style="display: none; margin: 20px 0px; padding: 12px; background: var(--grey-50); border-radius: 6px; font-size: 0.9em; color: var(--grey-600);">
                                <div style="margin-bottom: 6px; font-size: 12px;" id="modifiedByText"></div>
                                <div style="margin-bottom: 6px; font-size: 12px;" id="originalValueText"></div>
                                <div id="modificationNotesText" style="font-size: 12px;"></div>
                            </div>
                            <button class="revert-button" id="revertButton" style="display: inline-flex; padding: 8px 16px; background: var(--white); color: var(--grey-700); border: 1px solid var(--grey-300); border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 500; margin-bottom: 0px; width: fit-content;">
                                Revert to Original
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Expandable Sections Container -->
                <div class="expandable-sections-container">
                    <!-- View Document Section -->
                    <div class="expandable-section" id="viewDocumentSection">
                        <div class="expandable-section-header" id="viewDocumentHeader">
                            <span class="expandable-section-title">View Document</span>
                            <span class="expand-icon material-symbols-outlined" id="viewDocumentExpandIcon">expand_content</span>
                        </div>
                        <div class="expandable-section-content" id="viewDocumentContent">
                            <div class="document-viewer-section">
                                <div class="document-viewer" id="documentViewer">
                                    <!-- Document text will be displayed here -->
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Analyst Notes Section -->
                    <div class="expandable-section" id="analystNotesSection">
                        <div class="expandable-section-header" id="analystNotesHeader">
                            <span class="expandable-section-title">Analyst Notes</span>
                            <span class="expand-icon material-symbols-outlined" id="analystNotesExpandIcon">expand_content</span>
                        </div>
                        <div class="expandable-section-content" id="analystNotesContent">
                            <div style="padding: 12px 24px; border-radius: 0px; background-color: var(--white);">
                                <div style="display: flex; gap: 0px; margin-top: 0px; justify-content: flex-end; align-items: flex-end;">
                                    <button class="clear-notes-button" id="clearNotesButton" style="padding: 4px 8px; background: var(--white); color: var(--grey-700); border: 1px solid var(--grey-300); border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 500;">
                                        Clear
                                    </button>
                                </div>
                                <textarea class="analyst-notes" id="analystNotes" placeholder="You can mark anything for later here" style="width: 100%; min-height: 80px; padding: 12px; border: 1px solid var(--grey-300); border-radius: 6px; font-family: inherit; resize: vertical; font-size: 12px; margin-top: 8px; margin-bottom: 8px;"></textarea>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Custom Modal -->
    <!-- Modification Modal -->
    <div class="modal-overlay" id="modifyModalOverlay" style="display: none;">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-title" id="modifyModalTitle">Modifying Value</div>
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; font-weight: 500; color: var(--grey-700);">Value:</label>
                <input type="text" id="modifyValueInput" style="width: 100%; padding: 10px; border: 1px solid var(--grey-300); border-radius: 6px; font-size: 0.95em;" />
            </div>
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; font-weight: 500; color: var(--grey-700);">Reasons for Modification <span style="color: red;">*</span>:</label>
                <select id="modifyReasonDropdown" style="width: 100%; padding: 10px; border: 1px solid var(--grey-300); border-radius: 6px; font-size: 0.95em;">
                    <option value="">Select</option>
                    <option value="incorrect">Incorrect value extracted</option>
                    <option value="refinement">Correct Value was extracted but needs refinement</option>
                    <option value="context">Correct Value was extracted. Context-specific adjustment</option>
                </select>
                <div id="modifyReasonError" style="display: none; color: red; font-size: 0.875em; margin-top: 6px;">Please select a reason for modification</div>
            </div>
            <div id="modifySourceBlockContainer" style="display: none; margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; font-weight: 500; color: var(--grey-700);">Correct Source Block Text <span style="color: red;">*</span>:</label>
                <textarea id="modifySourceBlockInput" placeholder="Paste the correct source block text from the document..." style="width: 100%; min-height: 100px; padding: 10px; border: 1px solid var(--grey-300); border-radius: 6px; font-size: 0.95em; font-family: inherit; resize: vertical;"></textarea>
            </div>
            <div style="margin-bottom: 24px;">
                <label style="display: block; margin-bottom: 8px; font-weight: 500; color: var(--grey-700);">Modification Notes:</label>
                <textarea id="modifyNotesInput" placeholder="Enter a description..." style="width: 100%; min-height: 80px; padding: 10px; border: 1px solid var(--grey-300); border-radius: 6px; font-size: 0.95em; font-family: inherit; resize: vertical;"></textarea>
            </div>
            <div style="display: flex; gap: 12px; justify-content: flex-end;">
                <button id="modifyCancelButton" style="padding: 10px 20px; background: var(--white); color: var(--grey-700); border: 1px solid var(--grey-300); border-radius: 6px; cursor: pointer; font-size: 0.95em; font-weight: 500;">
                    Cancel
                </button>
                <button id="modifySaveButton" style="padding: 10px 20px; background: var(--teal); color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 0.95em; font-weight: 500; display: inline-flex; align-items: center; gap: 6px;">
                    Save Modification 
                </button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="modalOverlay">
        <div class="modal">
            <div class="modal-title" id="modalTitle"></div>
            <div class="modal-message" id="modalMessage"></div>
            <div class="modal-buttons" id="modalButtons"></div>
        </div>
    </div>

    <script>
        // API base URL - defaults to port 5001 (5000 is often used by AirPlay on macOS)
        // Can be overridden via window.API_PORT before this script runs
        const API_PORT = window.API_PORT || 5001;
        const API_BASE = `http://localhost:${API_PORT}/api`;
        let appState = {
            fileName: null,
            extractedText: null,
            chunks: null,
            stage1Results: null,
            stage2Results: null,
            blockIdToText: {}, // Map blockId to block text for highlighting
            blockIdToExtractedValue: {}, // Map blockId to extracted value (from Stage 2) - what was displayed on dashboard
            fieldToBlockId: {}, // Map field names to blockIds for clickable values
            blockIdToChunkId: {}, // Map blockId to chunkId
            chunkMetadata: {}, // Map chunkId to {chunkType, displayName, text}
            activeChunkId: null, // Currently active chunk
            overrides: {}, // Map blockId -> { originalValue, overriddenValue, reason, notes, sourceBlockText, overrideDate, overrideBy }
            analystNotes: {}, // Map blockId -> analyst notes text
            currentEditingBlockId: null, // Currently selected blockId for editing
            currentEditingValue: null, // Currently selected value for editing
            currentEditingLabel: null // Currently selected label for editing
        };

        // Initialize
        window.addEventListener('load', async () => {
            try {
                await fetch(`${API_BASE}/reset`, { method: 'POST' });
            } catch (error) {
                console.log('Could not reset server state:', error.message);
            }
            setupUpload();
            // Initialize expandable section icons
            updateExpandableSectionIcons();
            
            // Auto-load sample dashboard if URL has ?sample parameter
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has('sample')) {
                setTimeout(() => {
                    const viewSampleBtn = document.getElementById('viewSampleBtn');
                    if (viewSampleBtn) {
                        viewSampleBtn.click();
                    }
                }, 100);
            }
        });

        // ============================================
        // PAGE 1: UPLOAD
        // ============================================
        function setupUpload() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');
            const fileDeleteBtn = document.getElementById('fileDeleteBtn');
            const launchDashboardBtn = document.getElementById('launchDashboardBtn');
            const viewSampleBtn = document.getElementById('viewSampleBtn');

            // Click to upload
            uploadArea.addEventListener('click', () => fileInput.click());

            // Drag and drop
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });

            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('dragover');
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                const file = e.dataTransfer.files[0];
                if (file && file.type === 'application/pdf') {
                    handleFileUpload(file);
                } else {
                    alert('Please upload a PDF file');
                }
            });

            fileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    handleFileUpload(file);
                }
            });

            // File delete handler
            fileDeleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                deleteFile();
            });

            // Launch dashboard button
            launchDashboardBtn.addEventListener('click', async () => {
                if (!appState.fileName) return;
                showPage('progressPage');
                await processDocument();
            });

            // View sample dashboard button
            viewSampleBtn.addEventListener('click', () => {
                // Use the existing preview functionality
                    appState.fileName = 'Sample Document (Preview)';
                    appState.extractedText = 'This is sample document text for preview purposes.';
                    appState.stage2Results = {};
                    
                // Set up sample chunks (reuse existing sample data setup)
                setupSampleData();
                showPage('dashboardPage');
                renderDashboard();
            });
        }

        function setupSampleData() {
                    // Set up sample chunks with text
                    appState.chunks = [
                        {
                            chunkId: 'sample-cover-001',
                            chunkType: 'cover',
                            text: `REVOLVING CREDIT AGREEMENT

dated as of January 16, 2024

among

SAMPLE BORROWER INC., a Delaware corporation (the "Borrower"),

the Lenders from time to time party hereto,

and

SAMPLE BANK, N.A., as Administrative Agent

This Revolving Credit Agreement (this "Agreement") is entered into as of January 16, 2024, among Sample Borrower Inc., a Delaware corporation (the "Borrower"), the lenders from time to time party hereto (the "Lenders"), and Sample Bank, N.A., as administrative agent (the "Administrative Agent").

The Borrower has requested that the Lenders make available to the Borrower a revolving credit facility in an aggregate principal amount not to exceed $100,000,000. The Lenders are willing to make such credit facility available to the Borrower on the terms and conditions set forth herein.`
                        },
                        {
                            chunkId: 'sample-definitions-001',
                            chunkType: 'definitions',
                            text: `SECTION 1.01. Defined Terms. As used in this Agreement, the following terms have the meanings specified below:

"Commitment" means, with respect to each Lender, the commitment of such Lender to make Loans hereunder, expressed as an amount representing the maximum aggregate amount of such Lender's Revolving Credit Exposure hereunder, as such commitment may be (a) reduced from time to time pursuant to Section 2.08, (b) reduced or increased from time to time pursuant to assignments by or to such Lender pursuant to Section 10.04, and (c) increased from time to time pursuant to Section 2.20. The initial amount of each Lender's Commitment is set forth on Schedule 2.01, or in the Assignment and Assumption pursuant to which such Lender shall have assumed its Commitment, as applicable.

"Commitment Amount" means $100,000,000, as such amount may be reduced from time to time pursuant to Section 2.08 or increased from time to time pursuant to Section 2.20.

"Maturity Date" means January 1, 2029, or such earlier date on which the Commitments shall have been terminated or the Loans shall have been declared due and payable in accordance with the terms hereof.

"Revolving Credit Facility" means the revolving credit facility established pursuant to this Agreement, including the Revolving Credit Commitments and the Revolving Credit Loans made thereunder.

"Term Loan Facility" means the term loan facility established pursuant to Section 2.02, in an aggregate principal amount of $25,000,000.`
                        },
                        {
                            chunkId: 'sample-credits-001',
                            chunkType: 'credits',
                            text: `SECTION 2.01. Revolving Credit Commitments. Subject to the terms and conditions set forth herein, each Lender agrees to make Revolving Credit Loans to the Borrower from time to time during the Availability Period in an aggregate principal amount that will not result in (a) such Lender's Revolving Credit Exposure exceeding such Lender's Commitment or (b) the total Revolving Credit Exposures exceeding the total Commitments.

SECTION 2.02. Loans and Borrowings. (a) Each Loan shall be made as part of a Borrowing consisting of Loans made by the Lenders ratably in accordance with their respective Commitments.

(b) Subject to Section 2.14, each Borrowing shall be comprised entirely of ABR Loans or Eurodollar Loans as the Borrower may request in accordance herewith. Each Lender at its option may make any Eurodollar Loan by causing any domestic or foreign branch or Affiliate of such Lender to make such Loan; provided that any exercise of such option shall not affect the obligation of the Borrower to repay such Loan in accordance with the terms of this Agreement.

(c) At the commencement of each Interest Period for any Eurodollar Borrowing, such Borrowing shall be in an aggregate amount that is an integral multiple of $1,000,000 and not less than $5,000,000. At the time that each ABR Borrowing is made, such Borrowing shall be in an aggregate amount that is an integral multiple of $100,000 and not less than $1,000,000.

SECTION 2.03. Requests for Borrowings. To request a Borrowing, the Borrower shall notify the Administrative Agent of such request by telephone (a) in the case of a Eurodollar Borrowing, not later than 11:00 a.m., New York City time, three Business Days before the date of the proposed Borrowing or (b) in the case of an ABR Borrowing, not later than 11:00 a.m., New York City time, on the date of the proposed Borrowing.

SECTION 2.04. Interest Rates. (a) ABR Loans. Each ABR Loan shall bear interest at a rate per annum equal to the Alternate Base Rate plus the Applicable Margin.

(b) Eurodollar Loans. Each Eurodollar Loan shall bear interest at a rate per annum equal to the Adjusted LIBO Rate for the Interest Period in effect for such Borrowing plus the Applicable Margin.

(c) Default Interest. Notwithstanding the foregoing, if an Event of Default has occurred and is continuing, all outstanding Loans shall bear interest at a rate per annum equal to (i) in the case of ABR Loans, the Alternate Base Rate plus the Applicable Margin plus 2% per annum, and (ii) in the case of Eurodollar Loans, the Adjusted LIBO Rate for the applicable Interest Period plus the Applicable Margin plus 2% per annum.

SECTION 2.05. Fees. (a) Commitment Fee. The Borrower agrees to pay to the Administrative Agent for the account of each Lender a commitment fee, which shall accrue at the Applicable Rate on the average daily unused amount of the Commitment of such Lender during the period from and including the Effective Date to but excluding the date on which such Commitment terminates.

(b) Letter of Credit Fees. The Borrower agrees to pay (i) to the Administrative Agent for the account of each Lender a participation fee with respect to its participations in Letters of Credit, which shall accrue at the Applicable Rate on the average daily amount of such Lender's LC Exposure (excluding the portion thereof attributable to unreimbursed LC Disbursements) during the period from and including the Effective Date to but excluding the later of the date on which such Lender's Commitment terminates and the date on which such Lender ceases to have any LC Exposure, and (ii) to the Issuing Bank a fronting fee, which shall accrue at the rate of 0.125% per annum on the average daily amount of the LC Exposure (excluding the portion thereof attributable to unreimbursed LC Disbursements) during the period from and including the Effective Date to but excluding the later of the date of termination of the Commitments and the date on which there ceases to be any LC Exposure.`
                        },
                        {
                            chunkId: 'sample-representations-001',
                            chunkType: 'representations',
                            text: `SECTION 3.01. Representations and Warranties. The Borrower represents and warrants to the Lenders and the Administrative Agent that:

(a) Organization; Powers. The Borrower and each of its Subsidiaries is duly organized, validly existing and in good standing under the laws of the jurisdiction of its organization, has all requisite power and authority to carry on its business as now conducted and, except where the failure to do so, individually or in the aggregate, would not reasonably be expected to result in a Material Adverse Effect, is qualified to do business in, and is in good standing in, every jurisdiction where such qualification is required.

(b) Authorization; Enforceability. The Transactions are within the Borrower's corporate powers and have been duly authorized by all necessary corporate and, if required, stockholder action. This Agreement has been duly executed and delivered by the Borrower and constitutes a valid and binding obligation of the Borrower, enforceable in accordance with its terms, subject to applicable bankruptcy, insolvency, reorganization, moratorium or other laws affecting creditors' rights generally and subject to general principles of equity, regardless of whether considered in a proceeding in equity or at law.

(c) Governmental Approvals; No Conflicts. The Transactions (a) do not require any consent or approval of, registration or filing with, or any other action by, any Governmental Authority, except such as have been obtained or made and are in full force and effect, (b) will not violate any applicable law or regulation or the charter, by-laws or other organizational documents of the Borrower or any of its Subsidiaries or any order of any Governmental Authority, (c) will not violate or result in a default under any indenture, agreement or other instrument binding upon the Borrower or any of its Subsidiaries or its assets, or give rise to a right thereunder to require any payment to be made by the Borrower or any of its Subsidiaries, and (d) will not result in the creation or imposition of any Lien on any asset of the Borrower or any of its Subsidiaries.

(d) Use of Proceeds. The proceeds of the Loans will be used only for general corporate purposes, working capital, and permitted acquisitions.`
                        },
                        {
                            chunkId: 'sample-covenants-001',
                            chunkType: 'negative_covenants',
                            text: `SECTION 6.01. Negative Covenants. So long as any Lender shall have any Commitment hereunder, any Loan or other Obligation hereunder shall remain unpaid or unsatisfied, or any Letter of Credit shall remain outstanding, the Borrower shall not, and shall not permit any of its Subsidiaries to, directly or indirectly:

(a) Leverage Ratio. Permit the Leverage Ratio, determined as of the end of each fiscal quarter of the Borrower, to exceed (i) 4.00:1.00 for the fiscal quarters ending on or before December 31, 2024, (ii) 3.75:1.00 for the fiscal quarters ending on or before December 31, 2025, and (iii) 3.50:1.00 for the fiscal quarters ending thereafter.

(b) Interest Coverage Ratio. Permit the Interest Coverage Ratio, determined as of the end of each fiscal quarter of the Borrower, to be less than (i) 3.00:1.00 for the fiscal quarters ending on or before December 31, 2024, and (ii) 3.25:1.00 for the fiscal quarters ending thereafter.

(c) Indebtedness. Create, incur, assume or suffer to exist any Indebtedness, except: (i) Indebtedness under this Agreement and the other Loan Documents; (ii) Indebtedness outstanding on the date hereof and listed on Schedule 6.01(c) and any refinancings, refundings, renewals or extensions thereof; (iii) Indebtedness of the Borrower to any Subsidiary and of any Subsidiary to the Borrower or any other Subsidiary; (iv) Guarantees by the Borrower of Indebtedness of any Subsidiary and by any Subsidiary of Indebtedness of the Borrower or any other Subsidiary; (v) Indebtedness secured by Liens permitted by Section 6.02(f); and (vi) other unsecured Indebtedness in an aggregate principal amount not exceeding $10,000,000 at any time outstanding.

(d) Liens. Create, incur, assume or suffer to exist any Lien upon any of its property, assets or revenues, whether now owned or hereafter acquired, except for: (i) Liens securing the Obligations; (ii) Liens existing on the date hereof and listed on Schedule 6.02 and any renewals or extensions thereof; (iii) Liens for taxes not yet due or which are being contested in good faith by appropriate proceedings; (iv) statutory Liens of landlords, carriers, warehousemen, mechanics, materialmen and other Liens imposed by law; (v) pledges or deposits in the ordinary course of business in connection with workers' compensation, unemployment insurance and other social security legislation; and (vi) Liens securing Indebtedness permitted by Section 6.01(c)(v).`
                        },
                        {
                            chunkId: 'sample-events-001',
                            chunkType: 'events_of_default',
                            text: `SECTION 7.01. Events of Default. If any of the following events ("Events of Default") shall occur:

(a) Payment Default. The Borrower shall fail to pay (i) any principal of any Loan or any reimbursement obligation in respect of any LC Disbursement when and as the same shall become due and payable, whether at the due date thereof or at a date fixed for prepayment thereof or otherwise, or (ii) any interest on any Loan or any fee or any other amount (other than an amount referred to in clause (i) of this paragraph (a)) payable under this Agreement or any other Loan Document, when and as the same shall become due and payable, and such failure shall continue unremedied for a period of 3 Business Days.

(b) Covenant Default. The Borrower shall fail to observe or perform any covenant, condition or agreement contained in Section 5.01, 5.02, 5.03 (with respect to the Borrower's existence) or 5.08 or in Article VI, and such failure shall continue unremedied for a period of 30 days after notice thereof from the Administrative Agent or any Lender to the Borrower.

(c) Cross-Default. The Borrower or any of its Subsidiaries shall (i) fail to make any payment when due (whether by scheduled maturity, required prepayment, acceleration, demand, or otherwise) in respect of any Indebtedness (other than Indebtedness hereunder and Indebtedness under Swap Agreements) having an aggregate principal amount (including undrawn committed or available amounts and including amounts owing to all creditors under any combined or syndicated credit arrangement) of more than $1,000,000, or (ii) fail to observe or perform any other agreement or condition relating to any such Indebtedness or contained in any instrument or agreement evidencing, securing or relating thereto, or any other event shall occur or condition shall exist thereunder, if the effect of such failure, event or condition is to cause, or to permit the holder or holders of such Indebtedness (or a trustee or agent on behalf of such holders) to cause, such Indebtedness to be demanded or to become due or to be repurchased, prepaid, defeased or redeemed (automatically or otherwise), or an offer to repurchase, prepay, defease or redeem such Indebtedness to be made, prior to its stated maturity.

(d) Bankruptcy. The Borrower or any of its Subsidiaries shall become unable, admit in writing its inability or fail generally to pay its debts as they become due, or shall take any corporate action in furtherance of any such action.

(e) Insolvency Proceedings. Any proceeding shall be instituted by or against the Borrower or any of its Subsidiaries seeking to adjudicate it a bankrupt or insolvent, or seeking liquidation, winding up, reorganization, arrangement, adjustment, protection, relief, or composition of it or its debts under any law relating to bankruptcy, insolvency or reorganization or relief of debtors, or seeking the entry of an order for relief or the appointment of a receiver, trustee, custodian or other similar official for it or for any substantial part of its property and, in the case of any such proceeding instituted against it (but not instituted by it), either such proceeding shall remain undismissed or unstayed for a period of 60 days, or any of the actions sought in such proceeding (including, without limitation, the entry of an order for relief against, or the appointment of a receiver, trustee, custodian or other similar official for, it or for any substantial part of its property) shall occur.

(f) Judgment. There shall be entered against the Borrower or any of its Subsidiaries one or more final judgments or orders for the payment of money in an aggregate amount (as to all such judgments and orders) exceeding $1,000,000 (to the extent not covered by independent third-party insurance as to which the insurer does not dispute coverage), and (i) enforcement proceedings shall have been commenced by any creditor upon such judgment or order, (ii) there shall be any period of 30 consecutive days during which a stay of enforcement of such judgment or order, by reason of a pending appeal or otherwise, shall not be in effect, or (iii) such judgment or order shall not have been paid, discharged or vacated or have been bonded or stayed pending appeal.`
                        }
                    ];
                    
                    // Initialize override state
                    appState.overrides = {};
                    appState.currentEditingBlockId = null;
                    appState.currentEditingValue = null;
                    appState.currentEditingLabel = null;
                    
                    // Set up sample chunk metadata
                    appState.chunkMetadata = {};
                    appState.blockIdToChunkId = {};
                    appState.blockIdToText = {};
                    appState.blockIdToExtractedValue = {};
                    
                    appState.chunks.forEach(chunk => {
                        appState.chunkMetadata[chunk.chunkId] = {
                            chunkId: chunk.chunkId,
                            chunkType: chunk.chunkType,
                            displayName: getChunkDisplayName(chunk.chunkType),
                            title: chunk.title || getChunkDisplayName(chunk.chunkType),
                            text: chunk.text
                        };
                    });
                    
                    // Set up sample block mappings for clickable values
                    appState.blockIdToChunkId['sample-agreement-title'] = 'sample-cover-001';
                    appState.blockIdToChunkId['sample-borrowers'] = 'sample-cover-001';
                    appState.blockIdToChunkId['sample-agent'] = 'sample-cover-001';
                    appState.blockIdToChunkId['sample-effective-date'] = 'sample-cover-001';
                    appState.blockIdToChunkId['sample-commitment'] = 'sample-definitions-001';
                    appState.blockIdToChunkId['sample-maturity'] = 'sample-definitions-001';
                    appState.blockIdToChunkId['sample-revolving'] = 'sample-definitions-001';
                    appState.blockIdToChunkId['sample-term-loan'] = 'sample-definitions-001';
                    appState.blockIdToChunkId['sample-abr'] = 'sample-credits-001';
                    appState.blockIdToChunkId['sample-eurodollar'] = 'sample-credits-001';
                    appState.blockIdToChunkId['sample-commitment-fee'] = 'sample-credits-001';
                    appState.blockIdToChunkId['sample-lc-fee'] = 'sample-credits-001';
                    appState.blockIdToChunkId['sample-use-of-proceeds'] = 'sample-representations-001';
                    appState.blockIdToChunkId['sample-leverage-ratio'] = 'sample-covenants-001';
                    appState.blockIdToChunkId['sample-interest-coverage'] = 'sample-covenants-001';
                    appState.blockIdToChunkId['sample-payment-default'] = 'sample-events-001';
                    appState.blockIdToChunkId['sample-covenant-default'] = 'sample-events-001';
                    
            // Set sample block text for highlighting
                    appState.blockIdToText['sample-agreement-title'] = 'REVOLVING CREDIT AGREEMENT';
                    appState.blockIdToText['sample-borrowers'] = 'SAMPLE BORROWER INC., a Delaware corporation (the "Borrower")';
                    appState.blockIdToText['sample-agent'] = 'SAMPLE BANK, N.A., as Administrative Agent';
                    appState.blockIdToText['sample-effective-date'] = 'January 16, 2024';
                    appState.blockIdToText['sample-commitment'] = '$100,000,000';
                    appState.blockIdToText['sample-maturity'] = 'January 1, 2029';
                    appState.blockIdToText['sample-revolving'] = '$75,000,000';
                    appState.blockIdToText['sample-term-loan'] = '$25,000,000';
                    appState.blockIdToText['sample-abr'] = 'Alternate Base Rate plus the Applicable Margin';
                    appState.blockIdToText['sample-abr-margin'] = '2.50%';
                    appState.blockIdToText['sample-eurodollar'] = 'Adjusted LIBO Rate for the Interest Period in effect for such Borrowing plus the Applicable Margin';
                    appState.blockIdToText['sample-eurodollar-margin'] = '2.75%';
                    appState.blockIdToText['sample-commitment-fee'] = 'commitment fee, which shall accrue at the Applicable Rate on the average daily unused amount of the Commitment';
                    appState.blockIdToText['sample-lc-fee'] = 'Letter of Credit Fees';
                    appState.blockIdToChunkId['sample-abr-margin'] = 'sample-credits-001';
                    appState.blockIdToChunkId['sample-eurodollar-margin'] = 'sample-credits-001';
                    appState.blockIdToText['sample-use-of-proceeds'] = 'general corporate purposes, working capital, and permitted acquisitions';
                    appState.blockIdToText['sample-leverage-ratio'] = '4.00:1.00 for the fiscal quarters ending on or before December 31, 2024';
                    appState.blockIdToText['sample-interest-coverage'] = '3.00:1.00 for the fiscal quarters ending on or before December 31, 2024';
                    
                    // Store extracted values for sample threshold values and dates
                    appState.blockIdToExtractedValue['sample-leverage-ratio_thresholdValue_0'] = '4.00:1.00';
                    appState.blockIdToExtractedValue['sample-leverage-ratio_thresholdDate_0'] = 'December 31, 2024';
                    appState.blockIdToExtractedValue['sample-leverage-ratio_thresholdValue_1'] = '3.75:1.00';
                    appState.blockIdToExtractedValue['sample-leverage-ratio_thresholdDate_1'] = 'December 31, 2025';
                    appState.blockIdToExtractedValue['sample-leverage-ratio_thresholdValue_2'] = '3.50:1.00';
                    appState.blockIdToExtractedValue['sample-leverage-ratio_thresholdDate_2'] = 'December 31, 2026';
                    appState.blockIdToExtractedValue['sample-leverage-ratio_condition'] = 'Total Debt to EBITDA';
                    
                    appState.blockIdToExtractedValue['sample-interest-coverage_thresholdValue_0'] = '3.00:1.00';
                    appState.blockIdToExtractedValue['sample-interest-coverage_thresholdDate_0'] = 'December 31, 2024';
                    appState.blockIdToExtractedValue['sample-interest-coverage_thresholdValue_1'] = '3.25:1.00';
                    appState.blockIdToExtractedValue['sample-interest-coverage_thresholdDate_1'] = 'December 31, 2025';
                    appState.blockIdToExtractedValue['sample-interest-coverage_condition'] = 'EBITDA to Interest Expense';
                    appState.blockIdToText['sample-payment-default'] = '3 Business Days';
                    appState.blockIdToText['sample-covenant-default'] = '30 days after notice thereof from the Administrative Agent or any Lender to the Borrower';
                    
                    appState.activeChunkId = 'sample-cover-001';
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(0) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
        }

        function updateFileUploadUI(fileName, fileSize) {
            const fileUploadItem = document.getElementById('fileUploadItem');
            const fileNameEl = document.getElementById('fileName');
            const fileSizeEl = document.getElementById('fileSize');
            const launchDashboardBtn = document.getElementById('launchDashboardBtn');

            if (fileName && fileSize) {
                fileNameEl.textContent = fileName;
                fileSizeEl.textContent = `${formatFileSize(fileSize)} – 100% uploaded`;
                fileUploadItem.classList.add('visible');
                launchDashboardBtn.disabled = false;
                } else {
                fileUploadItem.classList.remove('visible');
                launchDashboardBtn.disabled = true;
                }
        }

        function deleteFile() {
            const fileInput = document.getElementById('fileInput');
            fileInput.value = '';
            appState.fileName = null;
            updateFileUploadUI(null, null);
            
            // Reset server state
            fetch(`${API_BASE}/reset`, { method: 'POST' }).catch(err => {
                console.log('Could not reset server state:', err.message);
            });
        }

        async function handleFileUpload(file) {
            const formData = new FormData();
            formData.append('file', file);

            try {
                // Show file in UI immediately
                updateFileUploadUI(file.name, file.size);

                const response = await fetch(`${API_BASE}/upload`, {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();
                if (data.status === 'success') {
                    appState.fileName = data.filename;
                    // Update UI with actual server response
                    updateFileUploadUI(data.filename, data.size);
                } else {
                    alert('Upload failed: ' + data.error);
                    deleteFile();
                }
            } catch (error) {
                alert('Error uploading file: ' + error.message);
                deleteFile();
            }
        }

        // ============================================
        // PAGE 2: PROGRESS
        // ============================================
        const progressSteps = [
            { label: 'Processing the document', duration: 3000 },
            { label: 'Chunking into articles', duration: 2000 },
            { label: 'Searching relevant blocks', duration: 4000 },
            { label: 'Extracting structured values', duration: 5000 },
            { label: 'Preparing dashboard', duration: 2000 }
        ];

        async function processDocument() {
            const progressBar = document.getElementById('progressBar');
            const progressStatus = document.getElementById('progressStatus');
            const progressTime = document.getElementById('progressTime');
            const progressStepsEl = document.getElementById('progressSteps');

            // Render steps
            progressStepsEl.innerHTML = progressSteps.map((step, idx) => `
                <div class="progress-step" id="step-${idx}">
                    <div class="step-check">${idx + 1}</div>
                    <div class="step-label">${step.label}</div>
                </div>
            `).join('');

            // Step 1: Process PDF
            updateProgress(0, 'Processing the document', progressSteps[0].duration);
            await executeStep(0);
            const processResult = await fetch(`${API_BASE}/process-pdf`, { method: 'POST' });
            const processData = await processResult.json();
            if (processData.status === 'success') {
                appState.extractedText = processData.text;
            }

            // Step 2: Chunk
            updateProgress(20, 'Chunking into articles', progressSteps[1].duration);
            await executeStep(1);
            const chunkResult = await fetch(`${API_BASE}/chunk`, { method: 'POST' });
            const chunkData = await chunkResult.json();
            if (chunkData.status === 'success') {
                appState.chunks = chunkData.chunks;
                // Build initial chunk metadata for all chunks
                chunkData.chunks.forEach(chunk => {
                    appState.chunkMetadata[chunk.chunkId] = {
                        chunkId: chunk.chunkId,
                        chunkType: chunk.chunkType || 'other',
                        displayName: getChunkDisplayName(chunk.chunkType || 'other'),
                        title: chunk.title || getChunkDisplayName(chunk.chunkType || 'other'),
                        text: chunk.text || ''
                    };
                });
            }

            // Step 3: Stage 1
            updateProgress(40, 'Searching relevant blocks', progressSteps[2].duration);
            await executeStep(2);
            const stage1Result = await fetch(`${API_BASE}/stage1`, { method: 'POST' });
            const stage1Data = await stage1Result.json();
            if (stage1Data.status === 'success') {
                appState.stage1Results = stage1Data.results;
                // Build blockId to text mapping and chunk mappings
                Object.values(stage1Data.results).forEach(chunkResult => {
                    const chunkId = chunkResult.chunkId;
                    const chunkType = chunkResult.chunkType;
                    
                    // Store chunk metadata
                    if (appState.chunks) {
                        const chunkInfo = appState.chunks.find(c => c.chunkId === chunkId);
                        if (chunkInfo) {
                            appState.chunkMetadata[chunkId] = {
                                chunkId: chunkId,
                                chunkType: chunkType,
                                displayName: getChunkDisplayName(chunkType),
                                title: chunkInfo.title || getChunkDisplayName(chunkType),
                                text: chunkInfo.text || ''
                            };
                        }
                    }
                    
                    // Map blockIds to chunkIds
                    chunkResult.blocks.forEach(block => {
                        appState.blockIdToText[block.blockId] = block.text || '';
                        appState.blockIdToChunkId[block.blockId] = chunkId;
                    });
                });
            }

            // Step 4: Stage 2
            updateProgress(60, 'Extracting structured values', progressSteps[3].duration);
            await executeStep(3);
            const stage2Result = await fetch(`${API_BASE}/stage2`, { method: 'POST' });
            const stage2Data = await stage2Result.json();
            if (stage2Data.status === 'success') {
                appState.stage2Results = stage2Data.results;
                // Build field to blockId mapping for clickable values
                // Also store extracted values for each blockId
                Object.values(stage2Data.results).forEach(chunkResult => {
                    if (chunkResult.extractions) {
                        chunkResult.extractions.forEach(extraction => {
                            if (extraction.values) {
                                Object.keys(extraction.values).forEach(fieldName => {
                                    appState.fieldToBlockId[fieldName] = extraction.blockId;
                                });
                                
                                // Store extracted values for the main blockId
                                // For negative covenants, we'll handle threshold values/dates separately
                                if (chunkResult.chunkType === 'negative_covenants') {
                                    // Store the main blockId's extracted values
                                    const baseBlockId = extraction.blockId;
                                    if (extraction.values.thresholdValues) {
                                        const thresholdValues = Array.isArray(extraction.values.thresholdValues) 
                                            ? extraction.values.thresholdValues 
                                            : [extraction.values.thresholdValues];
                                        const dates = Array.isArray(extraction.values.dates) 
                                            ? extraction.values.dates 
                                            : (extraction.values.dates ? [extraction.values.dates] : []);
                                        
                                        // Store each threshold value and date with unique blockIds
                                        thresholdValues.forEach((val, i) => {
                                            const valueBlockId = `${baseBlockId}_thresholdValue_${i}`;
                                            const dateBlockId = `${baseBlockId}_thresholdDate_${i}`;
                                            appState.blockIdToExtractedValue[valueBlockId] = val;
                                            if (dates[i]) {
                                                appState.blockIdToExtractedValue[dateBlockId] = dates[i];
                                            }
                                        });
                                    }
                                    // Store other values for the main blockId
                                    if (extraction.values.operator) {
                                        appState.blockIdToExtractedValue[`${baseBlockId}_operator`] = extraction.values.operator;
                                    }
                                    if (extraction.values.condition) {
                                        appState.blockIdToExtractedValue[`${baseBlockId}_condition`] = extraction.values.condition;
                                    }
                                    if (extraction.values.gracePeriod) {
                                        appState.blockIdToExtractedValue[`${baseBlockId}_gracePeriod`] = extraction.values.gracePeriod;
                                    }
                                } else {
                                    // For other chunk types, store all values under the main blockId
                                    Object.entries(extraction.values).forEach(([key, value]) => {
                                        if (value && value !== 'Not Found') {
                                            // For arrays, join them; otherwise use the value directly
                                            const displayValue = Array.isArray(value) ? value.join(', ') : value;
                                            appState.blockIdToExtractedValue[extraction.blockId] = displayValue;
                                        }
                                    });
                                }
                            }
                        });
                    }
                });
            }

            // Step 5: Prepare Dashboard
            updateProgress(80, 'Preparing dashboard', progressSteps[4].duration);
            await executeStep(4);

            // Complete
            updateProgress(100, 'Complete!', 0);
            await new Promise(resolve => setTimeout(resolve, 500));
            showPage('dashboardPage');
            renderDashboard();
        }

        function updateProgress(percent, status, remainingMs) {
            document.getElementById('progressBar').style.width = percent + '%';
            document.getElementById('progressStatus').textContent = status;
        }

        async function executeStep(stepIndex) {
            const stepEl = document.getElementById(`step-${stepIndex}`);
            stepEl.classList.add('active');
            await new Promise(resolve => setTimeout(resolve, progressSteps[stepIndex].duration));
            stepEl.classList.remove('active');
            stepEl.classList.add('completed');
            stepEl.querySelector('.step-check').innerHTML = '<span class="material-icons">check</span>';
        }

        // ============================================
        // PAGE 3: DASHBOARD
        // ============================================
        function getChunkDisplayName(chunkType) {
            const names = {
                'cover': 'Cover',
                'definitions': 'Definitions',
                'credits': 'Credits',
                'representations': 'Representations',
                'negative_covenants': 'Negative Covenants',
                'events_of_default': 'Events of Default',
                'other': 'Other'
            };
            return names[chunkType] || chunkType.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        }

        function renderDashboard() {
            // Update toolbar
            document.getElementById('toolbarFileName').textContent = appState.fileName || 'Document';

            // Initialize value details form
            initializeValueDetailsForm();

            // Render document viewer
            renderDocumentViewer();

            // Render dashboard sections
            renderDashboardSections();
            
            // Re-setup clickable value handlers after re-rendering
            setupClickableValueHandlers();
            
            // Setup expandable sections
            setupExpandableSections();
            
            // Update sticky note icons for all values with notes (after rendering)
            setTimeout(() => {
                if (appState.analystNotes) {
                    Object.keys(appState.analystNotes).forEach(blockId => {
                        if (appState.analystNotes[blockId] && appState.analystNotes[blockId].trim() !== '') {
                            updateStickyNoteIcon(blockId, true);
                        }
                    });
                }
            }, 0);
        }

        function renderDocumentViewer() {
            const viewer = document.getElementById('documentViewer');
            
            // Build chunk navigation HTML
            const chunks = Object.values(appState.chunkMetadata);
            // Set initial active chunk if not set
            if (!appState.activeChunkId && chunks.length > 0) {
                appState.activeChunkId = chunks[0].chunkId;
            }
            const activeChunk = appState.activeChunkId ? appState.chunkMetadata[appState.activeChunkId] : (chunks.length > 0 ? chunks[0] : null);
            
            let html = '';
            
            // Chunk Navigation Panel
            if (chunks.length > 0) {
                html += `
                    <div class="chunk-navigation">
                        <div class="chunk-dropdown" id="chunkDropdown">
                            <span>${activeChunk ? (activeChunk.title || activeChunk.displayName) : 'Select Chunk'}</span>
                            <span class="chunk-dropdown-arrow">▼</span>
                        </div>
                        <ul class="chunk-list" id="chunkList">
                            ${chunks.map(chunk => `
                                <li class="chunk-list-item ${chunk.chunkId === appState.activeChunkId ? 'active' : ''}" 
                                    data-chunk-id="${chunk.chunkId}">
                                    ${chunk.title || chunk.displayName}
                                </li>
                            `).join('')}
                        </ul>
                    </div>
                `;
            }
            
            // Document Content
            html += '<div class="document-content" id="documentContent">';
            
            if (appState.chunks && appState.chunks.length > 0) {
                // Show all chunks with section headers
                appState.chunks.forEach(chunk => {
                    const chunkMeta = appState.chunkMetadata[chunk.chunkId];
                    const displayName = chunkMeta ? chunkMeta.displayName : getChunkDisplayName(chunk.chunkType || 'other');
                    const text = chunk.text || '';
                    
                    html += `
                        <div class="chunk-section" data-chunk-id="${chunk.chunkId}">
                            <div class="chunk-section-header">${displayName}</div>
                            <div class="chunk-section-content">${escapeHtml(text)}</div>
                        </div>
                    `;
                });
            } else if (appState.extractedText) {
                // Fallback to full text if chunks not available
                const text = appState.extractedText.replace(/</g, '&lt;').replace(/>/g, '&gt;');
                html += `<div class="chunk-section-content" style="white-space: pre-wrap; word-wrap: break-word;">${text}</div>`;
            } else {
                html += '<p style="color: #737373;">No document text available</p>';
            }
            
            html += '</div>';
            viewer.innerHTML = html;
            
            // Set up chunk navigation event listeners
            setupChunkNavigation();
        }

        function setupChunkNavigation() {
            const dropdown = document.getElementById('chunkDropdown');
            const chunkList = document.getElementById('chunkList');
            
            // Toggle dropdown on click
            if (dropdown && chunkList) {
                dropdown.addEventListener('click', (e) => {
                    e.stopPropagation();
                    chunkList.classList.toggle('open');
                    
                    // Rotate arrow
                    const arrow = dropdown.querySelector('.chunk-dropdown-arrow');
                    if (arrow) {
                        arrow.style.transform = chunkList.classList.contains('open') ? 'rotate(180deg)' : 'rotate(0deg)';
                    }
                });
            }
            
            // Chunk list item clicks
            const chunkListItems = document.querySelectorAll('.chunk-list-item');
            chunkListItems.forEach(item => {
                item.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const chunkId = item.dataset.chunkId;
                    switchToChunk(chunkId);
                    // Close dropdown after selection
                    if (chunkList) {
                        chunkList.classList.remove('open');
                        const arrow = dropdown?.querySelector('.chunk-dropdown-arrow');
                        if (arrow) {
                            arrow.style.transform = 'rotate(0deg)';
                        }
                    }
                });
            });
            
            // Close dropdown when clicking outside
            document.addEventListener('click', (e) => {
                if (chunkList && dropdown && !chunkList.contains(e.target) && !dropdown.contains(e.target)) {
                    chunkList.classList.remove('open');
                    const arrow = dropdown.querySelector('.chunk-dropdown-arrow');
                    if (arrow) {
                        arrow.style.transform = 'rotate(0deg)';
                    }
                }
            });
        }

        function switchToChunk(chunkId) {
            appState.activeChunkId = chunkId;
            
            // Update active state in list
            document.querySelectorAll('.chunk-list-item').forEach(item => {
                if (item.dataset.chunkId === chunkId) {
                    item.classList.add('active');
                } else {
                    item.classList.remove('active');
                }
            });
            
            // Update dropdown
            const dropdown = document.getElementById('chunkDropdown');
            if (dropdown && appState.chunkMetadata[chunkId]) {
                const chunk = appState.chunkMetadata[chunkId];
                dropdown.querySelector('span:first-child').textContent = chunk.title || chunk.displayName;
            }
            
            // Scroll to chunk section
            const chunkSection = document.querySelector(`.chunk-section[data-chunk-id="${chunkId}"]`);
            if (chunkSection) {
                chunkSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }

        function hasRealData() {
            // Check if we have any real extracted data
            if (!appState.stage2Results || Object.keys(appState.stage2Results).length === 0) {
                return false;
            }
            
            // Check if any chunk has valid extractions
            for (const chunkResult of Object.values(appState.stage2Results)) {
                if (chunkResult.extractions && chunkResult.extractions.length > 0) {
                    for (const extraction of chunkResult.extractions) {
                        if (extraction.values && Object.keys(extraction.values).length > 0) {
                            const hasValidValue = Object.values(extraction.values).some(value => {
                                if (Array.isArray(value)) {
                                    return value.length > 0 && value.some(v => v && v !== 'Not Found');
                                }
                                return value && value !== 'Not Found';
                            });
                            if (hasValidValue) {
                                return true;
                            }
                        }
                    }
                }
            }
            return false;
        }

        function getSampleData() {
            return {
                coverData: {
                    agreementTitle: 'Sample Credit Agreement',
                    agreementTitleBlockId: 'sample-agreement-title',
                    borrowers: 'Sample Borrower Inc.',
                    borrowersBlockId: 'sample-borrowers',
                    administrativeAgent: 'Sample Bank, N.A.',
                    administrativeAgentBlockId: 'sample-agent',
                    effectiveDate: 'January 1, 2024',
                    effectiveDateBlockId: 'sample-effective-date'
                },
                definitionsData: {
                    commitmentAmount: '$100,000,000',
                    commitmentBlockId: 'sample-commitment',
                    maturityDate: 'January 1, 2029',
                    maturityBlockId: 'sample-maturity',
                    allCommitments: [
                        { label: 'Revolving Credit Facility', amount: '$75,000,000', blockId: 'sample-revolving' },
                        { label: 'Term Loan Facility', amount: '$25,000,000', blockId: 'sample-term-loan' }
                    ]
                },
                creditsData: {
                    abrLoan: {
                        blockId: 'sample-abr',
                        interestFormula: 'ABR + 2.50%',
                        abrMargin: '2.50%',
                        abrMarginBlockId: 'sample-abr-margin',
                        paymentTiming: 'Quarterly in arrears'
                    },
                    eurodollarLoan: {
                        blockId: 'sample-eurodollar',
                        interestFormula: 'LIBOR + 2.75%',
                        eurodollarMargin: '2.75%',
                        eurodollarMarginBlockId: 'sample-eurodollar-margin',
                        paymentTiming: 'Quarterly in arrears'
                    },
                    defaultInterest: {
                        blockId: 'sample-default-interest',
                        interestFormula: 'ABR + Applicable Margin + 2% per annum or LIBOR + Applicable Margin + 2% per annum',
                        marginReference: 'Applicable Margin',
                        paymentTiming: 'Quarterly in arrears'
                    },
                    fees: [
                        {
                            feeType: 'Commitment Fee',
                            accrualPeriod: 'Daily',
                            exclusions: 'None',
                            feeBase: 'Unused Commitment',
                            feeRate: '0.50%',
                            payment: 'Quarterly in arrears',
                            blockId: 'sample-commitment-fee'
                        },
                        {
                            feeType: 'Letter of Credit Fee',
                            accrualPeriod: 'Daily',
                            exclusions: 'None',
                            feeBase: 'L/C Amount',
                            feeRate: '1.00%',
                            payment: 'Quarterly in arrears',
                            blockId: 'sample-lc-fee'
                        }
                    ]
                },
                representationsData: {
                    useOfProceeds: 'General corporate purposes, working capital, and permitted acquisitions',
                    useOfProceedsBlockId: 'sample-use-of-proceeds'
                },
                covenantsData: [
                    {
                        blockId: 'sample-leverage-ratio',
                        title: 'Leverage Ratio',
                        operator: 'shall not exceed',
                        thresholds: [
                            { value: '4.00:1.00', date: 'December 31, 2024', valueBlockId: 'sample-leverage-ratio_thresholdValue_0', dateBlockId: 'sample-leverage-ratio_thresholdDate_0', index: 0 },
                            { value: '3.75:1.00', date: 'December 31, 2025', valueBlockId: 'sample-leverage-ratio_thresholdValue_1', dateBlockId: 'sample-leverage-ratio_thresholdDate_1', index: 1 },
                            { value: '3.50:1.00', date: 'December 31, 2026', valueBlockId: 'sample-leverage-ratio_thresholdValue_2', dateBlockId: 'sample-leverage-ratio_thresholdDate_2', index: 2 }
                        ],
                        condition: 'Total Debt to EBITDA'
                    },
                    {
                        blockId: 'sample-interest-coverage',
                        title: 'Interest Coverage Ratio',
                        operator: 'shall not be less than',
                        thresholds: [
                            { value: '3.00:1.00', date: 'December 31, 2024', valueBlockId: 'sample-interest-coverage_thresholdValue_0', dateBlockId: 'sample-interest-coverage_thresholdDate_0', index: 0 },
                            { value: '3.25:1.00', date: 'December 31, 2025', valueBlockId: 'sample-interest-coverage_thresholdValue_1', dateBlockId: 'sample-interest-coverage_thresholdDate_1', index: 1 }
                        ],
                        condition: 'EBITDA to Interest Expense'
                    }
                ],
                eventsData: [
                    {
                        blockId: 'sample-payment-default',
                        triggeredBy: 'Payment Default',
                        defaultType: 'Payment Default',
                        affectedObligation: 'Principal and Interest',
                        automatic: false,
                        category: 'Payment Default',
                        gracePeriod: '3 Business Days',
                        monetaryThreshold: '$1,000,000',
                        noticeRequired: 'Yes'
                    },
                    {
                        blockId: 'sample-covenant-default',
                        triggeredBy: 'Covenant Breach',
                        defaultType: 'Covenant Default',
                        affectedObligation: 'All Obligations',
                        automatic: false,
                        category: 'Covenant Default',
                        gracePeriod: '30 days',
                        monetaryThreshold: 'N/A',
                        noticeRequired: 'Yes'
                    }
                ]
            };
        }

        function renderDashboardSections() {
            const main = document.getElementById('dashboardMain');
            if (!main) {
                console.error('Dashboard main element not found');
                return;
            }
            
            let html = '';

            // Check if we have real data or need to show sample data
            const hasData = hasRealData();
            const isSampleData = !hasData;
            
            console.log('renderDashboardSections called:', {
                hasData,
                isSampleData,
                stage2Results: appState.stage2Results,
                stage2ResultsKeys: Object.keys(appState.stage2Results || {})
            });
            
            // Extract data from Stage 2 results or use sample data
            let coverData, definitionsData, creditsData, representationsData, covenantsData, eventsData;
            
            if (isSampleData) {
                const sample = getSampleData();
                coverData = sample.coverData || {};
                definitionsData = sample.definitionsData || {};
                creditsData = sample.creditsData || {};
                representationsData = sample.representationsData || {};
                covenantsData = sample.covenantsData || [];
                // For sample data, create eventsData structure with grace periods
                eventsData = {
                    events: sample.eventsData || [],
                    paymentDefaultPrincipalGracePeriod: '3 Business Days',
                    paymentDefaultPrincipalGracePeriodBlockId: 'sample-payment-default',
                    paymentDefaultInterestGracePeriod: '3 Business Days',
                    paymentDefaultInterestGracePeriodBlockId: 'sample-payment-default',
                    generalCovenantDefaultGracePeriod: '30 days',
                    generalCovenantDefaultGracePeriodBlockId: 'sample-covenant-default'
                };
                
                // Debug: Log sample data
                console.log('Sample data loaded:', {
                    coverData,
                    definitionsData,
                    creditsData: creditsData ? { abrLoan: creditsData.abrLoan, eurodollarLoan: creditsData.eurodollarLoan, fees: creditsData.fees?.length } : null,
                    representationsData,
                    covenantsData: covenantsData?.length,
                    eventsData: eventsData?.length
                });
            } else {
                coverData = extractCoverData();
                definitionsData = extractDefinitionsData();
                creditsData = extractCreditsData();
                representationsData = extractRepresentationsData();
                covenantsData = extractCovenantsData();
                eventsData = extractEventsData();
            }

            // Header Section - only show if we have at least one valid field
            if (coverData && (coverData.agreementTitle || coverData.borrowers || coverData.administrativeAgent || coverData.effectiveDate)) {
                html += `
                    <div class="dashboard-section header-section">
                        <div class="header-title">
                            ${makeClickable(coverData.agreementTitle || 'Credit Agreement', coverData.agreementTitleBlockId || null, 'Agreement Title')} 
                            between 
                            ${makeClickable(coverData.borrowers || 'Borrowers', coverData.borrowersBlockId || null, 'Borrowers')} 
                            and 
                            ${makeClickable(coverData.administrativeAgent || 'Administrative Agent', coverData.administrativeAgentBlockId || null, 'Administrative Agent')}
                        </div>
                        <div class="header-subtitle">
                            Effective Date: ${makeClickable(coverData.effectiveDate || 'N/A', coverData.effectiveDateBlockId || null, 'Effective Date')}
                        </div>
                    </div>
                `;
            } else if (isSampleData) {
                // Fallback: if sample data but coverData is missing, show a basic header
                html += `
                    <div class="dashboard-section header-section">
                        <div class="header-title">Sample Credit Agreement</div>
                        <div class="header-subtitle">Preview Mode - Sample Data</div>
                    </div>
                `;
            }

            // Facility Overview - only show if we have valid data
            if (definitionsData && (definitionsData.commitmentAmount || definitionsData.maturityDate || (definitionsData.allCommitments && definitionsData.allCommitments.length > 0) || (representationsData && representationsData.useOfProceeds))) {
                html += `
                    <div class="dashboard-section">
                        <div class="section-title">Facility Overview</div>
                        ${(definitionsData.allCommitments && definitionsData.allCommitments.length > 0) || definitionsData.maturityDate ? `
                            <div class="commitment-secondary">
                                ${definitionsData.allCommitments && definitionsData.allCommitments.length > 0 ? definitionsData.allCommitments.map(commitment => `
                                    <div class="commitment-card">
                                        <div class="commitment-card-label">${commitment.label}</div>
                                        <div class="commitment-card-value">
                                            ${makeClickable(commitment.amount, commitment.blockId, commitment.label)}
                                        </div>
                                    </div>
                                `).join('') : ''}
                                ${definitionsData.maturityDate ? `
                                    <div class="commitment-card">
                                        <div class="commitment-card-label">${definitionsData.maturityLabel || 'Maturity Date'}</div>
                                        <div class="commitment-card-value">
                                            ${makeClickable(definitionsData.maturityDate, definitionsData.maturityBlockId, 'Maturity Date')}
                                        </div>
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}
                        ${representationsData.useOfProceeds ? `
                            <div class="commitment-card" style="margin-top: 20px;">
                                <div class="commitment-card-label">Use of Proceeds</div>
                                <div class="commitment-card-value" style="font-size: 1em; line-height: 1.5;">
                                    ${makeClickable(representationsData.useOfProceeds, representationsData.useOfProceedsBlockId, 'Use of Proceeds')}
                                </div>
                            </div>
                        ` : ''}
                        ${eventsData && eventsData.paymentDefaultPrincipalGracePeriod ? `
                            <div class="contextual-note" style="margin-top: 20px;">
                                Payment Default Principal applies here at ${makeClickable(eventsData.paymentDefaultPrincipalGracePeriod, eventsData.paymentDefaultPrincipalGracePeriodBlockId || null, 'Payment Default Principal Grace Period')}. 
                                (<a href="#events-of-default" onclick="scrollToSection('events-of-default'); return false;">Refer Events of Default</a>)
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // Pricing Overview - only show if we have at least one valid pricing card
            const pricingCards = [
                renderPricingCard('ABR Loan', creditsData.abrLoan),
                renderPricingCard('Eurodollar Loan', creditsData.eurodollarLoan),
                renderPricingCard('Default Interest', creditsData.defaultInterest)
            ].filter(card => card !== '');
            
            if (pricingCards.length > 0) {
                html += `
                    <div class="dashboard-section">
                        <div class="section-title">Pricing Overview</div>
                        <div class="pricing-cards">
                            ${pricingCards.join('')}
                        </div>
                        ${eventsData && eventsData.paymentDefaultInterestGracePeriod ? `
                            <div class="contextual-note" style="margin-top: 20px;">
                                Payment Default interest applies here at ${makeClickable(eventsData.paymentDefaultInterestGracePeriod, eventsData.paymentDefaultInterestGracePeriodBlockId || null, 'Payment Default Interest Grace Period')}. 
                                (<a href="#events-of-default" onclick="scrollToSection('events-of-default'); return false;">Refer Events of Default</a>)
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // Negative Covenants - only show if blocks were found AND have meaningful extracted values
            const validCovenants = covenantsData.filter(covenant => {
                // For sample data, always show (blockId starts with 'sample-')
                if (covenant.blockId && covenant.blockId.startsWith('sample-')) {
                    return true;
                }
                // Check if block text exists in Stage 1 results
                const blockText = appState.blockIdToText[covenant.blockId];
                if (!blockText || blockText === 'Not Found' || blockText.trim() === '') {
                    return false;
                }
                // Also check if the title itself contains "Not Found" (in case blockId contains it)
                const title = covenant.title || '';
                if (title.includes('Not Found')) {
                    return false;
                }
                // Check if covenant has at least one meaningful extracted value
                // Must have at least: valid thresholds, operator, or condition
                const hasValidThresholds = covenant.thresholds && covenant.thresholds.length > 0;
                const hasValidOperator = covenant.operator && 
                    covenant.operator !== 'Not Found' && 
                    covenant.operator !== 'N/A' && 
                    covenant.operator.trim() !== '';
                const hasValidCondition = covenant.condition && 
                    covenant.condition !== 'Not Found' && 
                    covenant.condition !== 'N/A' && 
                    covenant.condition.trim() !== '';
                
                // Only show if at least one meaningful value exists
                return hasValidThresholds || hasValidOperator || hasValidCondition;
            });
            
            if (validCovenants.length > 0) {
                html += `
                    <div class="dashboard-section">
                        <div class="section-title">Negative Covenants</div>
                        ${validCovenants.map(covenant => renderCovenantCard(covenant)).join('')}
                        ${eventsData && eventsData.generalCovenantDefaultGracePeriod ? `
                            <div class="contextual-note" style="margin-top: 20px;">
                                Covenant Default applies here at ${makeClickable(eventsData.generalCovenantDefaultGracePeriod, eventsData.generalCovenantDefaultGracePeriodBlockId || null, 'General Covenant Default Grace Period')}. 
                                (<a href="#events-of-default" onclick="scrollToSection('events-of-default'); return false;">Refer Events of Default</a>)
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // Fees Table - only show if we have valid fees
            if (creditsData && creditsData.fees && creditsData.fees.length > 0) {
                html += `
                    <div class="dashboard-section">
                        <div class="section-title">Fees</div>
                        ${renderFeesTable(creditsData.fees)}
                        ${creditsData.paymentDefaultGracePeriod ? `
                            <div class="contextual-note">
                                If interest or fees payment is delayed by ${makeClickable(creditsData.paymentDefaultGracePeriod, creditsData.paymentDefaultGracePeriodBlockId || appState.fieldToBlockId['paymentDefaultGracePeriod'] || null, 'Payment Default Grace Period')}, 
                                a default shall be made. (<a href="#events-of-default" onclick="scrollToSection('events-of-default'); return false;">Refer Events of Default</a>)
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // Events of Default - only show if we have valid events
            // Filter events - for sample data, always show
            const eventsArray = eventsData && eventsData.events ? eventsData.events : (Array.isArray(eventsData) ? eventsData : []);
            const validEvents = eventsArray.filter(event => {
                if (!event) return false;
                if (event.blockId && event.blockId.startsWith('sample-')) {
                    return true;
                }
                return isBlockValid(event.blockId);
            });
            
            if (validEvents.length > 0) {
                html += `
                    <div class="dashboard-section" id="events-of-default">
                        <div class="section-title">Events of Default</div>
                        ${renderEventsTable(validEvents)}
                    </div>
                `;
            }

            // Ensure we always have content (fallback for debugging)
            if (html.trim() === '') {
                html = '<div class="dashboard-section"><p style="color: var(--grey-500); text-align: center; padding: 40px;">No content to display</p></div>';
            }
            
            // Debug: Log rendering info
            console.log('Dashboard rendering:', {
                isSampleData,
                htmlLength: html.length,
                sectionsCount: (html.match(/dashboard-section/g) || []).length,
                hasCoverData: !!coverData,
                hasDefinitionsData: !!definitionsData,
                hasCreditsData: !!creditsData
            });

            main.innerHTML = html;
        }
        
        // Value Descriptors Mapping
        function getValueDescriptor(valueLabel) {
            const descriptors = {
                // Cover Section
                'Agreement Title': 'The official title of the credit agreement document.',
                'Borrowers': 'The entity or entities that are borrowing funds under this credit agreement.',
                'Administrative Agent': 'The financial institution or entity acting as the administrative agent for the lenders.',
                'Effective Date': 'The date on which the credit agreement becomes effective and legally binding.',
                
                // Facility Overview
                'Revolving Credit Facility': 'The total amount lenders have committed to make available under the revolving credit facility, which can be borrowed, repaid, and reborrowed.',
                'Term Loan Facility': 'The total amount of the term loan facility, which is typically drawn once and repaid over time.',
                'Maturity Date': 'The date on which the credit facility matures and all outstanding amounts become due and payable.',
                'Use of Proceeds': 'The permitted uses for the loan proceeds as specified in the credit agreement.',
                
                // Pricing Overview
                'ABR Loan - Interest Formula': 'The formula used to calculate the interest rate for Alternate Base Rate (ABR) loans.',
                'ABR Loan - ABR Margin': 'The margin added to the Alternate Base Rate to determine the interest rate for ABR loans.',
                'Eurodollar Loan - Interest Formula': 'The formula used to calculate the interest rate for Eurodollar loans.',
                'Eurodollar Loan - Eurodollar Margin': 'The margin added to the Eurodollar rate (typically LIBOR) to determine the interest rate.',
                'Default Interest - Interest Formula': 'The interest rate formula applied when an event of default has occurred and is continuing.',
                'Default Interest - Margin Reference': 'The margin reference used in calculating default interest rates.',
                'Default Interest - Payment Timing': 'When default interest payments are due and payable.',
                'ABR Loan - Payment Timing': 'When interest payments for ABR loans are due and payable.',
                'Eurodollar Loan - Payment Timing': 'When interest payments for Eurodollar loans are due and payable.',
                
                // Fees
                'Commitment Fee': 'A fee charged on the unused portion of the credit commitment.',
                'Letter of Credit Fee': 'A fee charged for issuing and maintaining letters of credit.',
                'Fee Rate': 'The rate at which the fee is calculated.',
                'Fee Base': 'The base amount on which the fee is calculated.',
                'Accrual Period': 'The period over which the fee accrues.',
                'Payment': 'When the fee is payable.',
                
                // Negative Covenants
                'Leverage Ratio - Threshold Value': 'The maximum permitted leverage ratio threshold that must not be exceeded.',
                'Leverage Ratio - Threshold Date': 'The date associated with the leverage ratio threshold.',
                'Leverage Ratio - Condition': 'The financial metric being tested (e.g., Total Debt to EBITDA).',
                'Interest Coverage Ratio - Threshold Value': 'The minimum required interest coverage ratio.',
                'Interest Coverage Ratio - Threshold Date': 'The date associated with the interest coverage ratio threshold.',
                'Interest Coverage Ratio - Condition': 'The financial metric being tested (e.g., EBITDA to Interest Expense).',
                
                // Events of Default
                'Triggered By': 'The event or condition that triggers this default.',
                'Default Type': 'The classification or type of default event.',
                'Affected Obligation': 'The specific obligation or obligations affected by this default.',
                'Automatic': 'Whether the default becomes effective automatically or requires notice.',
                'Category': 'The category or classification of the default event.',
                'Grace Period': 'The period of time allowed to cure or remedy the default before it becomes effective.',
                'Monetary Threshold': 'Any monetary threshold that must be met for the default to apply.',
                'Notice Required': 'Whether written notice is required before the default becomes effective.',
                
                // Contextual Notes
                'Payment Default Principal Grace Period': 'The grace period allowed before a payment default on principal becomes effective.',
                'Payment Default Interest Grace Period': 'The grace period allowed before a payment default on interest becomes effective.',
                'General Covenant Default Grace Period': 'The grace period allowed before a general covenant default becomes effective.'
            };
            
            // Try exact match first
            if (descriptors[valueLabel]) {
                return descriptors[valueLabel];
            }
            
            // Try partial matches for dynamic labels
            for (const [key, value] of Object.entries(descriptors)) {
                if (valueLabel.includes(key.split(' - ')[0]) || key.includes(valueLabel.split(' - ')[0])) {
                    return value;
                }
            }
            
            // Default descriptor
            return 'This is an extracted value from the credit agreement document.';
        }

        function updateValueDisplay(value) {
            const valueDisplayElement = document.getElementById('valueDisplay');
            if (valueDisplayElement) {
                valueDisplayElement.textContent = value;
                // If value is longer than 30 characters, use much smaller font size
                if (value && value.length > 30) {
                    valueDisplayElement.style.fontSize = '14px';
                } else {
                    valueDisplayElement.style.fontSize = '1.1em';
                }
            }
        }

        function setupClickableValueHandlers() {
            // Use event delegation to handle clicks on clickable values
            // This prevents XSS vulnerabilities from unescaped blockIds in onclick handlers
            const dashboardMain = document.getElementById('dashboardMain');
            if (dashboardMain) {
                dashboardMain.addEventListener('click', (e) => {
                    const clickableValue = e.target.closest('.clickable-value');
                    if (clickableValue) {
                        const blockId = clickableValue.dataset.blockId;
                        const valueLabel = clickableValue.dataset.valueLabel || 'Extracted Value';
                        if (blockId) {
                            // Check for override first - this is the source of truth
                            const override = appState.overrides[blockId];
                            
                            // Get original value from override, extracted value, or blockIdToText
                            // Priority: override.originalValue > blockIdToExtractedValue > blockIdToText
                            const originalValue = override 
                                ? override.originalValue 
                                : (appState.blockIdToExtractedValue[blockId] || appState.blockIdToText[blockId] || '');
                            
                            // Always use override value if it exists, otherwise get from DOM
                            let displayValue;
                            if (override) {
                                // Use override value directly - this is the source of truth
                                displayValue = override.overriddenValue;
                            } else {
                                // No override, get from DOM text content
                                let currentValue = clickableValue.textContent.trim();
                                currentValue = currentValue.replace(/\s*Analyst-adjusted\s*/gi, '').trim();
                                displayValue = currentValue;
                            }
                            
                            // Populate More Details section
                            populateValueDetails(blockId, displayValue, originalValue, valueLabel);
                            
                            // Handle highlighting based on override reason
                            // Only highlight if:
                            // - No override exists, OR
                            // - Override reason is "refinement" (value is correct, just needs formatting)
                            if (!override || override.reason === 'refinement') {
                                highlightBlock(blockId);
                            }
                            // Do NOT highlight if reason is "incorrect" or "context"
                        }
                    }
                });
            }
        }

        // Custom Modal Functions
        function showModal(title, message, buttons) {
            const overlay = document.getElementById('modalOverlay');
            const modalTitle = document.getElementById('modalTitle');
            const modalMessage = document.getElementById('modalMessage');
            const modalButtons = document.getElementById('modalButtons');
            
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            modalButtons.innerHTML = '';
            
            buttons.forEach(button => {
                const btn = document.createElement('button');
                btn.className = `modal-button ${button.primary ? 'modal-button-primary' : 'modal-button-secondary'}`;
                btn.textContent = button.label;
                btn.onclick = () => {
                    hideModal();
                    if (button.onClick) {
                        button.onClick();
                    }
                };
                modalButtons.appendChild(btn);
            });
            
            overlay.classList.add('show');
        }

        function hideModal() {
            const overlay = document.getElementById('modalOverlay');
            overlay.classList.remove('show');
        }

        // Close modal when clicking outside
        document.addEventListener('click', (e) => {
            const overlay = document.getElementById('modalOverlay');
            if (e.target === overlay) {
                hideModal();
            }
        });

        function initializeValueDetailsForm() {
            // Hide the form content and show the empty state message
            const moreDetailsContent = document.getElementById('moreDetailsContent');
            const moreDetailsEmpty = document.getElementById('moreDetailsEmpty');
            const moreDetailsSection = document.getElementById('moreDetailsSection');
            
            if (moreDetailsContent) {
                // Remove inline styles to let CSS handle display
                moreDetailsContent.style.display = '';
            }
            if (moreDetailsEmpty) {
                moreDetailsEmpty.style.display = 'block';
            }
            
            // Hide all content elements when no value is selected
            hideValueDetailsContent();
            
            // Reset editing state
            appState.currentEditingBlockId = null;
            appState.currentEditingValue = null;
            appState.currentEditingLabel = null;
            
            // Default state when no value is selected:
            // More Details collapsed, View Document expanded, Analyst Notes collapsed
            collapseMoreDetails();
            expandViewDocument();
            collapseAnalystNotes();
            
            // Update icons to reflect current state
            updateExpandableSectionIcons();
        }
        
        function hideValueDetailsContent() {
            // Hide all content elements
            const valueDetailsHeading = document.getElementById('valueDetailsHeading');
            const valueDetailsDescriptor = document.getElementById('valueDetailsDescriptor');
            const valueDisplayContainer = document.getElementById('valueDisplayContainer');
            const modificationHistory = document.getElementById('modificationHistory');
            
            if (valueDetailsHeading) {
                valueDetailsHeading.style.display = 'none';
            }
            if (valueDetailsDescriptor) {
                valueDetailsDescriptor.style.display = 'none';
            }
            if (valueDisplayContainer) {
                valueDisplayContainer.style.display = 'none';
            }
            if (modificationHistory) {
                modificationHistory.style.display = 'none';
            }
        }
        
        function showValueDetailsContent() {
            // Show all content elements
            const valueDetailsHeading = document.getElementById('valueDetailsHeading');
            const valueDetailsDescriptor = document.getElementById('valueDetailsDescriptor');
            const valueDisplayContainer = document.getElementById('valueDisplayContainer');
            const modificationHistory = document.getElementById('modificationHistory');
            
            if (valueDetailsHeading) {
                valueDetailsHeading.style.display = 'flex';
            }
            if (valueDetailsDescriptor) {
                valueDetailsDescriptor.style.display = 'block';
            }
            if (valueDisplayContainer) {
                valueDisplayContainer.style.display = 'flex';
            }
            // modificationHistory visibility is controlled by override state, so don't force show it here
        }

        function populateValueDetails(blockId, currentValue, originalValue, valueLabel) {
            appState.currentEditingBlockId = blockId;
            appState.currentEditingValue = currentValue;
            appState.currentEditingLabel = valueLabel;
            
            // ALWAYS read from appState.overrides as the source of truth
            const override = appState.overrides[blockId];
            const isOverridden = !!override;
            
            // Get the actual original value
            // Priority: override.originalValue > blockIdToExtractedValue > originalValue parameter > currentValue
            const actualOriginalValue = override 
                ? override.originalValue 
                : (appState.blockIdToExtractedValue[blockId] || originalValue || currentValue);
            
            // Get the display value - always prefer override if it exists
            const displayValue = override ? override.overriddenValue : currentValue;
            
            // Show the content section
            const moreDetailsContent = document.getElementById('moreDetailsContent');
            const moreDetailsEmpty = document.getElementById('moreDetailsEmpty');
            const moreDetailsSection = document.getElementById('moreDetailsSection');
            
            // Remove inline display style to let CSS handle it via expanded class
            moreDetailsContent.style.display = '';
            moreDetailsEmpty.style.display = 'none';
            
            // Show all content elements when a value is selected
            showValueDetailsContent();
            
            // Expand More Details section
            if (moreDetailsSection) {
                moreDetailsSection.classList.add('expanded');
            }
            // Update icons after expanding
            updateExpandableSectionIcons();
            
            // Set heading
            const headingElement = document.getElementById('valueDetailsHeading');
            const headingSpan = headingElement.querySelector('span');
            if (headingSpan) {
                headingSpan.textContent = valueLabel;
            } else {
                headingElement.textContent = valueLabel;
            }
            
            // Set descriptor
            const descriptor = getValueDescriptor(valueLabel);
            document.getElementById('valueDetailsDescriptor').textContent = descriptor;
            
            // Set value display - use the displayValue we calculated above
            updateValueDisplay(displayValue);
            
            // Show/hide modify and revert buttons
            document.getElementById('modifyButton').style.display = 'inline-flex';
            document.getElementById('revertButton').style.display = isOverridden ? 'inline-flex' : 'none';
            
            // Show modification history if overridden
            const modificationHistory = document.getElementById('modificationHistory');
            if (isOverridden) {
                modificationHistory.style.display = 'block';
                const modifiedDate = new Date(override.overrideDate).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                document.getElementById('modifiedByText').textContent = `Modified by ${override.overrideBy} on ${modifiedDate}`;
                document.getElementById('originalValueText').textContent = `Original Extracted Value: ${actualOriginalValue}`;
                document.getElementById('modificationNotesText').textContent = override.notes ? `Notes: ${override.notes}` : '';
            } else {
                modificationHistory.style.display = 'none';
            }
            
            // Load analyst notes if saved
            const analystNotes = document.getElementById('analystNotes');
            if (appState.analystNotes && appState.analystNotes[blockId]) {
                analystNotes.value = appState.analystNotes[blockId];
            } else {
                analystNotes.value = '';
            }
            
            // Update sticky note icon in dashboard
            updateStickyNoteIcon(blockId, !!(appState.analystNotes && appState.analystNotes[blockId]));
            
            // Set up event listeners
            setupValueDetailsListeners();
            
            // Default state when value is clicked:
            // If value is modified: More Details expanded, View Document collapsed, Analyst Notes collapsed
            // If value is not modified: More Details expanded, View Document expanded, Analyst Notes collapsed
            expandMoreDetails();
            if (isOverridden) {
                collapseViewDocument();
                collapseAnalystNotes();
                // Ensure class is added to More Details and panel when View Document is collapsed
                const viewDocumentSection = document.getElementById('viewDocumentSection');
                const valueDetailsPanel = document.querySelector('.value-details-panel');
                if (moreDetailsSection && viewDocumentSection && !viewDocumentSection.classList.contains('expanded')) {
                    moreDetailsSection.classList.add('view-document-collapsed');
                    if (valueDetailsPanel) {
                        valueDetailsPanel.classList.add('view-doc-collapsed');
                    }
                }
            } else {
                expandViewDocument();
                collapseAnalystNotes();
                // Ensure class is removed from More Details and panel when View Document is expanded
                const valueDetailsPanel = document.querySelector('.value-details-panel');
                if (moreDetailsSection) {
                    moreDetailsSection.classList.remove('view-document-collapsed');
                }
                if (valueDetailsPanel) {
                    valueDetailsPanel.classList.remove('view-doc-collapsed');
                }
            }
            
            // Highlight the block in document viewer
            highlightBlock(blockId);
        }

        function resetValueDetailsForm() {
            const valueInput = document.getElementById('valueInput');
            const reasonDropdown = document.getElementById('reasonDropdown');
            const sourceBlockContainer = document.getElementById('sourceBlockContainer');
            const sourceBlockInput = document.getElementById('sourceBlockInput');
            const saveButton = document.getElementById('saveOverrideButton');
            const modifiedIndicator = document.getElementById('valueModifiedIndicator');
            const originalValueText = document.getElementById('originalValueText');
            
            const blockId = appState.currentEditingBlockId;
            if (!blockId) return;
            
            const override = appState.overrides[blockId];
            // Priority: override.originalValue > blockIdToExtractedValue > blockIdToText > valueInput.value
            const originalValue = override 
                ? override.originalValue 
                : (appState.blockIdToExtractedValue[blockId] || appState.blockIdToText[blockId] || valueInput.value);
            
            // Check if current input value differs from original
            const currentInputValue = valueInput.value.trim();
            const isModified = currentInputValue !== originalValue;
            
            // Update modified indicator - only show if user has started typing
            if (isModified && valueInput.value.trim() !== '') {
                modifiedIndicator.style.display = 'block';
                modifiedIndicator.textContent = 'Value is being modified';
                reasonDropdown.disabled = false;
            } else {
                modifiedIndicator.style.display = 'none';
                if (!override) {
                    reasonDropdown.disabled = true;
                    reasonDropdown.value = '';
                } else {
                    reasonDropdown.disabled = false;
                    reasonDropdown.value = override.reason || '';
                    // If already saved, show "Value modified"
                    modifiedIndicator.style.display = 'block';
                    modifiedIndicator.textContent = 'Value modified';
                }
            }
            
            // Handle source block input visibility based on reason
            if (reasonDropdown.value === 'incorrect') {
                sourceBlockContainer.style.display = 'block';
                sourceBlockInput.classList.add('visible');
                if (override && override.sourceBlockText) {
                    sourceBlockInput.value = override.sourceBlockText;
                } else {
                    sourceBlockInput.value = '';
                }
            } else {
                sourceBlockContainer.style.display = 'none';
                sourceBlockInput.classList.remove('visible');
            }
            
            // Set analyst notes if override exists
            const analystNotes = document.getElementById('analystNotes');
            if (override && override.notes) {
                analystNotes.value = override.notes;
            } else {
                analystNotes.value = '';
            }
            
            // Update save button state
            updateSaveButtonState();
        }

        function setupValueDetailsListeners() {
            // Modify button
            const modifyButton = document.getElementById('modifyButton');
            if (modifyButton) {
                modifyButton.onclick = () => {
                    openModifyModal();
                };
            }
            
            // Revert button
            const revertButton = document.getElementById('revertButton');
            if (revertButton) {
                revertButton.onclick = () => {
                    showRevertConfirmation();
                };
            }
            
            // Analyst Notes - Auto-save on input
            const analystNotes = document.getElementById('analystNotes');
            if (analystNotes) {
                // Auto-save with debounce to avoid too many saves
                let saveTimeout;
                analystNotes.addEventListener('input', () => {
                    clearTimeout(saveTimeout);
                    saveTimeout = setTimeout(() => {
                        saveAnalystNotes();
                    }, 500); // Save 500ms after user stops typing
                });
            }
            
            // Analyst Notes Clear button
            const clearNotesButton = document.getElementById('clearNotesButton');
            if (clearNotesButton) {
                clearNotesButton.onclick = () => {
                    clearAnalystNotes();
                };
            }
            
            // Expandable section headers
            setupExpandableSections();
        }
        
        function setupExpandableSections() {
            const moreDetailsHeader = document.getElementById('moreDetailsHeader');
            const moreDetailsSection = document.getElementById('moreDetailsSection');
            const viewDocumentHeader = document.getElementById('viewDocumentHeader');
            const analystNotesHeader = document.getElementById('analystNotesHeader');
            const viewDocumentSection = document.getElementById('viewDocumentSection');
            const analystNotesSection = document.getElementById('analystNotesSection');
            
            if (moreDetailsHeader && moreDetailsSection) {
                moreDetailsHeader.onclick = () => {
                    toggleExpandableSection(moreDetailsSection, null);
                };
            }
            
            if (viewDocumentHeader && viewDocumentSection) {
                viewDocumentHeader.onclick = () => {
                    toggleExpandableSection(viewDocumentSection, analystNotesSection);
                };
            }
            
            if (analystNotesHeader && analystNotesSection) {
                analystNotesHeader.onclick = () => {
                    toggleExpandableSection(analystNotesSection, viewDocumentSection);
                };
            }
        }
        
        function toggleExpandableSection(sectionToToggle, sectionToClose) {
            const isExpanded = sectionToToggle.classList.contains('expanded');
            const moreDetailsSection = document.getElementById('moreDetailsSection');
            const viewDocumentSection = document.getElementById('viewDocumentSection');
            
            if (isExpanded) {
                // Collapse the section
                sectionToToggle.classList.remove('expanded');
            } else {
                // Expand the section and close the other one (mutually exclusive)
                sectionToToggle.classList.add('expanded');
                if (sectionToClose) {
                    sectionToClose.classList.remove('expanded');
                }
                
                // If More Details is being expanded and no value is selected, ensure content is hidden
                if (sectionToToggle.id === 'moreDetailsSection' && !appState.currentEditingBlockId) {
                    hideValueDetailsContent();
                    const moreDetailsEmpty = document.getElementById('moreDetailsEmpty');
                    if (moreDetailsEmpty) {
                        moreDetailsEmpty.style.display = 'block';
                    }
                }
            }
            
            // Update More Details height class based on View Document state
            const valueDetailsPanel = document.querySelector('.value-details-panel');
            if (moreDetailsSection && moreDetailsSection.classList.contains('expanded')) {
                if (viewDocumentSection && !viewDocumentSection.classList.contains('expanded')) {
                    moreDetailsSection.classList.add('view-document-collapsed');
                    if (valueDetailsPanel) {
                        valueDetailsPanel.classList.add('view-doc-collapsed');
                    }
                } else {
                    moreDetailsSection.classList.remove('view-document-collapsed');
                    if (valueDetailsPanel) {
                        valueDetailsPanel.classList.remove('view-doc-collapsed');
                    }
                }
            }
            
            // Update icons for all sections
            updateExpandableSectionIcons();
        }
        
        function updateExpandableSectionIcons() {
            // More Details Section
            const moreDetailsSection = document.getElementById('moreDetailsSection');
            const moreDetailsIcon = document.getElementById('moreDetailsExpandIcon');
            if (moreDetailsSection && moreDetailsIcon) {
                if (moreDetailsSection.classList.contains('expanded')) {
                    moreDetailsIcon.textContent = 'collapse_content';
                } else {
                    moreDetailsIcon.textContent = 'expand_content';
                }
            }
            
            // View Document Section
            const viewDocumentSection = document.getElementById('viewDocumentSection');
            const viewDocumentIcon = document.getElementById('viewDocumentExpandIcon');
            if (viewDocumentSection && viewDocumentIcon) {
                if (viewDocumentSection.classList.contains('expanded')) {
                    viewDocumentIcon.textContent = 'collapse_content';
                } else {
                    viewDocumentIcon.textContent = 'expand_content';
                }
            }
            
            // Analyst Notes Section
            const analystNotesSection = document.getElementById('analystNotesSection');
            const analystNotesIcon = document.getElementById('analystNotesExpandIcon');
            if (analystNotesSection && analystNotesIcon) {
                if (analystNotesSection.classList.contains('expanded')) {
                    analystNotesIcon.textContent = 'collapse_content';
                } else {
                    analystNotesIcon.textContent = 'expand_content';
                }
            }
        }
        
        function expandMoreDetails() {
            const moreDetailsSection = document.getElementById('moreDetailsSection');
            if (moreDetailsSection) {
                moreDetailsSection.classList.add('expanded');
                updateExpandableSectionIcons();
            }
        }
        
        function collapseMoreDetails() {
            const moreDetailsSection = document.getElementById('moreDetailsSection');
            if (moreDetailsSection) {
                moreDetailsSection.classList.remove('expanded');
                updateExpandableSectionIcons();
            }
        }
        
        function expandViewDocument() {
            const viewDocumentSection = document.getElementById('viewDocumentSection');
            const analystNotesSection = document.getElementById('analystNotesSection');
            const moreDetailsSection = document.getElementById('moreDetailsSection');
            const valueDetailsPanel = document.querySelector('.value-details-panel');
            
            if (viewDocumentSection) {
                viewDocumentSection.classList.add('expanded');
            }
            if (analystNotesSection) {
                analystNotesSection.classList.remove('expanded');
            }
            // Remove class from More Details when View Document is expanded
            if (moreDetailsSection) {
                moreDetailsSection.classList.remove('view-document-collapsed');
            }
            // Remove class from panel when View Document is expanded
            if (valueDetailsPanel) {
                valueDetailsPanel.classList.remove('view-doc-collapsed');
            }
            updateExpandableSectionIcons();
        }
        
        function collapseAnalystNotes() {
            const analystNotesSection = document.getElementById('analystNotesSection');
            if (analystNotesSection) {
                analystNotesSection.classList.remove('expanded');
                updateExpandableSectionIcons();
            }
        }
        
        function collapseViewDocument() {
            const viewDocumentSection = document.getElementById('viewDocumentSection');
            const moreDetailsSection = document.getElementById('moreDetailsSection');
            const valueDetailsPanel = document.querySelector('.value-details-panel');
            if (viewDocumentSection) {
                viewDocumentSection.classList.remove('expanded');
                // Add class to More Details to allow it to take more height
                if (moreDetailsSection && moreDetailsSection.classList.contains('expanded')) {
                    moreDetailsSection.classList.add('view-document-collapsed');
                }
                // Add class to panel to shrink container
                if (valueDetailsPanel) {
                    valueDetailsPanel.classList.add('view-doc-collapsed');
                }
                updateExpandableSectionIcons();
            }
        }
        
        function openModifyModal() {
            const blockId = appState.currentEditingBlockId;
            if (!blockId) return;
            
            const override = appState.overrides[blockId];
            const currentValue = override ? override.overriddenValue : (document.getElementById('valueDisplay').textContent);
            const valueLabel = appState.currentEditingLabel || 'Value';
            
            // Set modal title
            document.getElementById('modifyModalTitle').textContent = `Modifying ${valueLabel} Value`;
            
            // Set current value
            document.getElementById('modifyValueInput').value = currentValue;
            
            // Set reason dropdown (if override exists, pre-fill it)
            const reasonDropdown = document.getElementById('modifyReasonDropdown');
            if (override && override.reason) {
                reasonDropdown.value = override.reason;
            } else {
                reasonDropdown.value = '';
            }
            
            // Handle source block container based on reason
            const sourceBlockContainer = document.getElementById('modifySourceBlockContainer');
            const sourceBlockInput = document.getElementById('modifySourceBlockInput');
            if (reasonDropdown.value === 'incorrect') {
                sourceBlockContainer.style.display = 'block';
                // Pre-fill source block text if it exists
                if (override && override.sourceBlockText) {
                    sourceBlockInput.value = override.sourceBlockText;
                } else {
                    sourceBlockInput.value = '';
                }
            } else {
                sourceBlockContainer.style.display = 'none';
                sourceBlockInput.value = '';
            }
            
            // Pre-fill notes if override exists
            const notesInput = document.getElementById('modifyNotesInput');
            if (override && override.notes) {
                notesInput.value = override.notes;
            } else {
                notesInput.value = '';
            }
            
            // Clear error message when opening modal
            const errorElement = document.getElementById('modifyReasonError');
            if (errorElement) {
                errorElement.style.display = 'none';
            }
            
            // Show modal
            const modalOverlay = document.getElementById('modifyModalOverlay');
            modalOverlay.style.display = 'flex';
            
            // Set up modal listeners
            setupModifyModalListeners();
            
            // Close modal when clicking outside
            modalOverlay.onclick = (e) => {
                if (e.target === modalOverlay) {
                    // Validate before closing
                    if (!validateReasonBeforeClose()) {
                        e.stopPropagation();
                        return;
                    }
                    modalOverlay.style.display = 'none';
                }
            };
        }
        
        function validateReasonBeforeClose() {
            const reasonDropdown = document.getElementById('modifyReasonDropdown');
            const errorElement = document.getElementById('modifyReasonError');
            
            if (!reasonDropdown.value) {
                // Show error message
                errorElement.style.display = 'block';
                return false;
            } else {
                // Hide error message if reason is selected
                errorElement.style.display = 'none';
                return true;
            }
        }
        
        function setupModifyModalListeners() {
            const cancelButton = document.getElementById('modifyCancelButton');
            const saveButton = document.getElementById('modifySaveButton');
            const reasonDropdown = document.getElementById('modifyReasonDropdown');
            const sourceBlockContainer = document.getElementById('modifySourceBlockContainer');
            const sourceBlockInput = document.getElementById('modifySourceBlockInput');
            const errorElement = document.getElementById('modifyReasonError');
            
            // Handle reason dropdown change - show/hide source block text field and clear error
            reasonDropdown.addEventListener('change', () => {
                // Clear error when reason is selected
                errorElement.style.display = 'none';
                
                if (reasonDropdown.value === 'incorrect') {
                    sourceBlockContainer.style.display = 'block';
                } else {
                    sourceBlockContainer.style.display = 'none';
                    sourceBlockInput.value = '';
                }
            });
            
            // Cancel button
            cancelButton.onclick = () => {
                // Validate before closing
                if (!validateReasonBeforeClose()) {
                    return;
                }
                document.getElementById('modifyModalOverlay').style.display = 'none';
            };
            
            // Save button
            saveButton.onclick = () => {
                const valueInput = document.getElementById('modifyValueInput');
                const reason = reasonDropdown.value;
                const notes = document.getElementById('modifyNotesInput').value.trim();
                const sourceBlockText = sourceBlockInput.value.trim();
                
                if (!valueInput.value.trim()) {
                    alert('Please enter a value');
                    return;
                }
                
                if (!reason) {
                    // Show error message instead of alert
                    errorElement.style.display = 'block';
                    return;
                }
                
                // If reason is "incorrect", require source block text
                if (reason === 'incorrect' && !sourceBlockText) {
                    alert('Please paste the correct source block text from the document');
                    return;
                }
                
                // Close modal first
                document.getElementById('modifyModalOverlay').style.display = 'none';
                
                // Then save modification (this will update both dashboard and value details)
                saveModification(valueInput.value.trim(), reason, notes, sourceBlockText);
            };
        }
        
        function saveModification(newValue, reason, notes, sourceBlockText) {
            const blockId = appState.currentEditingBlockId;
            if (!blockId) return;
            
            const override = appState.overrides[blockId];
            // Priority: override.originalValue > blockIdToExtractedValue > blockIdToText > newValue
            const originalValue = override 
                ? override.originalValue 
                : (appState.blockIdToExtractedValue[blockId] || appState.blockIdToText[blockId] || newValue);
            
            const overrideData = {
                originalValue: originalValue,
                overriddenValue: newValue,
                reason: reason,
                notes: notes,
                sourceBlockText: reason === 'incorrect' ? (sourceBlockText || '') : null,
                overrideDate: new Date().toISOString(),
                overrideBy: 'Analyst'
            };
            
            // Save override to appState FIRST - this is the source of truth
            appState.overrides[blockId] = overrideData;
            
            // Immediately refresh value details view - it will read from appState.overrides
            const valueLabel = appState.currentEditingLabel;
            
            // Update the value display element directly and immediately
            updateValueDisplay(overrideData.overriddenValue);
            
            // Update revert button visibility
            const revertButton = document.getElementById('revertButton');
            if (revertButton) {
                revertButton.style.display = 'inline-flex';
            }
            
            // Update modification history
            const modificationHistory = document.getElementById('modificationHistory');
            if (modificationHistory) {
                modificationHistory.style.display = 'block';
                const modifiedDate = new Date(overrideData.overrideDate).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                document.getElementById('modifiedByText').textContent = `Modified by ${overrideData.overrideBy} on ${modifiedDate}`;
                document.getElementById('originalValueText').textContent = `Original Extracted Value: ${overrideData.originalValue}`;
                document.getElementById('modificationNotesText').textContent = overrideData.notes ? `Notes: ${overrideData.notes}` : '';
            }
            
            // Then call populateValueDetails to ensure everything is in sync
            populateValueDetails(blockId, overrideData.overriddenValue, overrideData.originalValue, valueLabel);
            
            // Handle highlighting based on override reason
            // Only highlight if reason is "refinement" (value is correct, just needs formatting)
            if (overrideData.reason === 'refinement') {
                highlightBlock(blockId);
            }
            // Do NOT highlight if reason is "incorrect" or "context"
            
            // Finally re-render dashboard to show updated value
            renderDashboard();
        }
        
        function showRevertConfirmation() {
            showModal(
                'Revert to Original',
                'Are you sure you want to revert to the original extracted value?',
                [
                    {
                        label: 'Cancel',
                        primary: false,
                        onClick: () => {
                            // Do nothing
                        }
                    },
                    {
                        label: 'Yes Continue',
                        primary: true,
                        onClick: () => {
                            revertOverride();
                        }
                    }
                ]
            );
        }
        
        function saveAnalystNotes() {
            const blockId = appState.currentEditingBlockId;
            if (!blockId) return;
            
            const notes = document.getElementById('analystNotes').value.trim();
            
            if (!appState.analystNotes) {
                appState.analystNotes = {};
            }
            
            // Save notes (empty string if cleared)
            if (notes) {
                appState.analystNotes[blockId] = notes;
            } else {
                // Remove from appState if empty
                if (appState.analystNotes[blockId]) {
                    delete appState.analystNotes[blockId];
                }
            }
            
            // Update sticky note icon in dashboard
            updateStickyNoteIcon(blockId, !!notes);
        }
        
        function clearAnalystNotes() {
            const blockId = appState.currentEditingBlockId;
            if (!blockId) return;
            
            document.getElementById('analystNotes').value = '';
            
            // Remove from appState
            if (appState.analystNotes && appState.analystNotes[blockId]) {
                delete appState.analystNotes[blockId];
            }
            
            // Remove sticky note icon from dashboard
            updateStickyNoteIcon(blockId, false);
        }
        
        function updateStickyNoteIcon(blockId, hasNotes) {
            // Find all clickable values with this blockId and add/remove sticky note icon
            const clickableValues = document.querySelectorAll(`.clickable-value[data-block-id="${blockId}"]`);
            clickableValues.forEach(clickableValue => {
                // Find the parent container (could be a div, td, or other element)
                let parent = clickableValue.parentElement;
                
                // Remove existing sticky note icon if any (could be next sibling or in parent)
                const existingIcon = parent.querySelector('.sticky-note-icon');
                if (existingIcon) {
                    existingIcon.remove();
                }
                
                // Also check if icon is a direct next sibling
                if (clickableValue.nextSibling && clickableValue.nextSibling.classList && clickableValue.nextSibling.classList.contains('sticky-note-icon')) {
                    clickableValue.nextSibling.remove();
                }
                
                // Add sticky note icon if has notes
                if (hasNotes) {
                    const icon = document.createElement('span');
                    icon.className = 'sticky-note-icon';
                    icon.innerHTML = '<span class="material-icons">sticky_note_2</span>';
                    icon.style.cssText = 'margin-left: 6px; font-size: 0.9em; vertical-align: middle; cursor: default; display: inline-block;';
                    icon.title = 'Analyst has added notes';
                    // Insert after the clickable value
                    if (clickableValue.nextSibling) {
                        clickableValue.parentElement.insertBefore(icon, clickableValue.nextSibling);
                    } else {
                        clickableValue.parentElement.appendChild(icon);
                    }
                }
            });
        }
        
        // Click outside handler - return to default state (single global listener)
        if (!window.valueDetailsClickOutsideHandler) {
            window.valueDetailsClickOutsideHandler = function(event) {
                const moreDetailsSection = document.getElementById('moreDetailsSection');
                const moreDetailsContent = document.getElementById('moreDetailsContent');
                
                if (!moreDetailsSection || !moreDetailsContent) return;
                
                // Check if click is outside the more details section
                if (moreDetailsContent.style.display === 'block' && 
                    !moreDetailsSection.contains(event.target) &&
                    !event.target.closest('.clickable-value')) {
                    
                    // Check if there are unsaved changes
                    const valueInput = document.getElementById('valueInput');
                    const reasonDropdown = document.getElementById('reasonDropdown');
                    const blockId = appState.currentEditingBlockId;
                    
                    if (blockId) {
                        const override = appState.overrides[blockId];
                        // Priority: override.originalValue > blockIdToExtractedValue > blockIdToText > valueInput.value
            const originalValue = override 
                ? override.originalValue 
                : (appState.blockIdToExtractedValue[blockId] || appState.blockIdToText[blockId] || valueInput.value);
                        const currentInputValue = valueInput.value.trim();
                        const isModified = currentInputValue !== originalValue;
                        const hasReason = reasonDropdown.value && reasonDropdown.value !== '';
                        
                    if (isModified && hasReason && !valueInput.disabled) {
                        // There are unsaved changes - show modal
                        showModal(
                            'Unsaved Changes',
                            'You have unsaved changes. You would go back to the previous value. Continue editing or discard changes?',
                            [
                                {
                                    label: 'Continue Editing',
                                    primary: false,
                                    onClick: () => {
                                        // Stay on current value, do nothing
                                    }
                                },
                                {
                                    label: 'Discard Changes',
                                    primary: true,
                                    onClick: () => {
                                        initializeValueDetailsForm();
                                    }
                                }
                            ]
                        );
                    } else {
                        // No unsaved changes, just close
                        initializeValueDetailsForm();
                    }
                    }
                }
            };
            document.addEventListener('click', window.valueDetailsClickOutsideHandler);
        }

        function updateSaveButtonState() {
            const valueInput = document.getElementById('valueInput');
            const reasonDropdown = document.getElementById('reasonDropdown');
            const saveButton = document.getElementById('saveOverrideButton');
            const modifiedIndicator = document.getElementById('valueModifiedIndicator');
            
            const blockId = appState.currentEditingBlockId;
            if (!blockId) {
                saveButton.disabled = true;
                return;
            }
            
            const override = appState.overrides[blockId];
            // Priority: override.originalValue > blockIdToExtractedValue > blockIdToText > valueInput.value
            const originalValue = override 
                ? override.originalValue 
                : (appState.blockIdToExtractedValue[blockId] || appState.blockIdToText[blockId] || valueInput.value);
            const currentInputValue = valueInput.value.trim();
            const isModified = currentInputValue !== originalValue;
            const hasReason = reasonDropdown.value && reasonDropdown.value !== '';
            
            // Enable save if value is modified and reason is selected
            if (isModified && hasReason) {
                saveButton.disabled = false;
                // Show indicator with "Value is being modified" text
                if (modifiedIndicator) {
                    modifiedIndicator.style.display = 'block';
                    modifiedIndicator.textContent = 'Value is being modified';
                }
            } else {
                saveButton.disabled = true;
                // Hide indicator if not modified (unless already saved)
                if (!isModified && modifiedIndicator) {
                    const override = appState.overrides[blockId];
                    if (!override) {
                        modifiedIndicator.style.display = 'none';
                    }
                }
            }
        }

        function saveOverride() {
            const blockId = appState.currentEditingBlockId;
            const valueInput = document.getElementById('valueInput');
            const reasonDropdown = document.getElementById('reasonDropdown');
            const sourceBlockInput = document.getElementById('sourceBlockInput');
            const analystNotes = document.getElementById('analystNotes');
            
            if (!blockId || !valueInput.value.trim() || !reasonDropdown.value) {
                return;
            }
            
            const originalValue = appState.overrides[blockId] 
                ? appState.overrides[blockId].originalValue 
                : (appState.blockIdToText[blockId] || valueInput.value);
            
            const override = {
                originalValue: originalValue,
                overriddenValue: valueInput.value.trim(),
                reason: reasonDropdown.value,
                notes: analystNotes.value.trim(),
                sourceBlockText: reasonDropdown.value === 'incorrect' ? sourceBlockInput.value.trim() : null,
                overrideDate: new Date().toISOString(),
                overrideBy: 'Analyst'
            };
            
            // Save override
            appState.overrides[blockId] = override;
            
            // Re-render dashboard to show override badge
            renderDashboard();
            
            // Update the form to show saved state
            resetValueDetailsForm();
            
            // Show success feedback with modal
            showModal(
                'Changes Saved',
                'Your changes have been saved successfully.',
                [
                    {
                        label: 'OK',
                        primary: true,
                        onClick: () => {
                            // Update save button state
                            const saveButton = document.getElementById('saveOverrideButton');
                            updateSaveButtonState();
                        }
                    }
                ]
            );
        }

        function revertOverride() {
            const blockId = appState.currentEditingBlockId;
            if (!blockId || !appState.overrides[blockId]) {
                return;
            }
            
            // Get original value before deleting override
            const originalValue = appState.overrides[blockId].originalValue;
            
            // Remove override from appState FIRST
            delete appState.overrides[blockId];
            
            // Immediately refresh value details view with original value
            const valueLabel = appState.currentEditingLabel;
            // Force refresh - override is removed, so it will show original value
            populateValueDetails(blockId, originalValue, originalValue, valueLabel);
            
            // Then re-render dashboard to remove override badge
            renderDashboard();
            
            // Highlight block (restore original behavior)
            highlightBlock(blockId);
        }
        
        function enableEditing() {
            const valueInput = document.getElementById('valueInput');
            const editIcon = document.getElementById('editIcon');
            if (valueInput && editIcon) {
                valueInput.disabled = false;
                valueInput.focus();
                editIcon.style.display = 'none';
            }
        }

        function renderPricingCard(title, data) {
            if (!data || !data.blockId) return '';
            // Only render if block is valid (or is sample data)
            if (!isBlockValid(data.blockId) && !data.blockId.startsWith('sample-')) return '';
            
            // Check if we have at least one valid field
            const hasValidData = data.interestFormula || 
                                (title === 'ABR Loan' && data.abrMargin) || 
                                (title === 'Eurodollar Loan' && data.eurodollarMargin) ||
                                (data.margin && title !== 'ABR Loan' && title !== 'Eurodollar Loan') || 
                                (title === 'Default Interest' && (data.marginReference || data.paymentTiming)) ||
                                data.paymentTiming;
            
            if (!hasValidData) return '';
            
            return `
                <div class="pricing-card">
                    <div class="pricing-card-title">${title}</div>
                    ${data.interestFormula && data.interestFormula !== 'Not Found' ? `
                        <div class="pricing-item">
                            <div class="pricing-item-label">Interest Formula</div>
                            <div class="pricing-item-value">${makeClickable(data.interestFormula, data.blockId, `${title} - Interest Formula`)}</div>
                        </div>
                    ` : ''}
                    ${title === 'ABR Loan' && data.abrMargin && data.abrMargin !== 'Not Found' ? `
                        <div class="pricing-item">
                            <div class="pricing-item-label">ABR Margin</div>
                            <div class="pricing-item-value">${makeClickable(data.abrMargin, data.abrMarginBlockId, 'ABR Loan - ABR Margin')}</div>
                        </div>
                    ` : ''}
                    ${title === 'Eurodollar Loan' && data.eurodollarMargin && data.eurodollarMargin !== 'Not Found' ? `
                        <div class="pricing-item">
                            <div class="pricing-item-label">Eurodollar Margin</div>
                            <div class="pricing-item-value">${makeClickable(data.eurodollarMargin, data.eurodollarMarginBlockId, 'Eurodollar Loan - Eurodollar Margin')}</div>
                        </div>
                    ` : ''}
                    ${data.margin && title !== 'ABR Loan' && title !== 'Eurodollar Loan' && data.margin !== 'Not Found' ? `
                        <div class="pricing-item">
                            <div class="pricing-item-label">Margin</div>
                            <div class="pricing-item-value">${makeClickable(data.margin, data.blockId, `${title} - Margin`)}</div>
                        </div>
                    ` : ''}
                    ${title === 'Default Interest' && data.marginReference && data.marginReference !== 'Not Found' ? `
                        <div class="pricing-item">
                            <div class="pricing-item-label">Margin Reference</div>
                            <div class="pricing-item-value">${makeClickable(data.marginReference, data.blockId, 'Default Interest - Margin Reference')}</div>
                        </div>
                    ` : ''}
                    ${data.paymentTiming && data.paymentTiming !== 'Not Found' ? `
                        <div class="pricing-item">
                            <div class="pricing-item-label">Payment Timing</div>
                            <div class="pricing-item-value">${makeClickable(data.paymentTiming, data.blockId, `${title} - Payment Timing`)}</div>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        function renderFeesTable(fees) {
            if (!fees || fees.length === 0) {
                return '<p style="color: #737373;">No fee data available</p>';
            }
            return `
                <div class="table-wrapper">
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>Fee Type</th>
                                <th>Accrual Period</th>
                                <th>Exclusions</th>
                                <th>Fee Base</th>
                                <th>Fee Rate</th>
                                <th>Payment</th>
                            </tr>
                        </thead>
                        <tbody>
                        ${fees.map(fee => `
                            <tr>
                                <td>${fee.feeType || 'N/A'}</td>
                                <td>${makeClickable(fee.accrualPeriod || 'N/A', fee.blockId, `${fee.feeType} - Accrual Period`)}</td>
                                <td>${makeClickable(fee.exclusions || 'N/A', fee.blockId, `${fee.feeType} - Exclusions`)}</td>
                                <td>${makeClickable(fee.feeBase || 'N/A', fee.blockId, `${fee.feeType} - Fee Base`)}</td>
                                <td>${makeClickable(fee.feeRate || 'N/A', fee.blockId, `${fee.feeType} - Fee Rate`)}</td>
                                <td>${makeClickable(fee.payment || 'N/A', fee.blockId, `${fee.feeType} - Payment`)}</td>
                            </tr>
                        `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
        }

        function renderCovenantCard(covenant) {
            const thresholds = covenant.thresholds || [];
            const covenantName = covenant.title || covenant.blockId;
            const operator = covenant.operator || '';
            
            return `
                <div class="covenant-card">
                    <div class="covenant-title">
                        ${covenantName}${operator ? ` ${operator}` : ''}
                    </div>
                    ${thresholds.length > 0 ? `
                        <div class="threshold-display">
                            ${thresholds.map(threshold => `
                                <div class="threshold-block">
                                    <div class="threshold-value">${makeClickable(threshold.value || 'N/A', threshold.valueBlockId || covenant.blockId, `${covenantName} - Threshold Value`)}</div>
                                    <div class="threshold-date">${threshold.date ? makeClickable(threshold.date, threshold.dateBlockId || covenant.blockId, `${covenantName} - Threshold Date`) : ''}</div>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                    ${covenant.condition ? `
                        <div class="covenant-condition">
                            <strong>Condition:</strong> ${makeClickable(covenant.condition, `${covenant.blockId}_condition`, `${covenantName} - Condition`)}
                        </div>
                    ` : ''}
                </div>
            `;
        }

        function renderEventsTable(events) {
            if (!events || events.length === 0) {
                return '<p style="color: #737373;">No events of default data available</p>';
            }
            return `
                <div class="table-wrapper">
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th>Triggered By</th>
                                <th>Default Type</th>
                                <th>Affected Obligation</th>
                                <th>Automatic?</th>
                                <th>Category</th>
                                <th>Grace Period</th>
                                <th>Monetary Threshold</th>
                                <th>Notice Required</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${events.map(event => `
                                <tr>
                                    <td>${makeClickable(event.triggeredBy || 'N/A', event.blockId, 'Triggered By')}</td>
                                    <td>${makeClickable(event.defaultType || 'N/A', event.blockId, 'Default Type')}</td>
                                    <td>${makeClickable(event.affectedObligation || 'N/A', event.blockId, 'Affected Obligation')}</td>
                                    <td>${makeClickable(event.automatic ? 'Yes' : 'No', event.blockId, 'Automatic')}</td>
                                    <td>${makeClickable(event.category || 'N/A', event.blockId, 'Category')}</td>
                                    <td>${makeClickable(event.gracePeriod || 'N/A', event.blockId, 'Grace Period')}</td>
                                    <td>${makeClickable(event.monetaryThreshold || 'N/A', event.blockId, 'Monetary Threshold')}</td>
                                    <td>${makeClickable(event.noticeRequired || 'N/A', event.blockId, 'Notice Required')}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
        }

        // ============================================
        // DATA EXTRACTION HELPERS
        // ============================================
        // Helper function to check if a block is valid (was found in Stage 1)
        function isBlockValid(blockId) {
            if (!blockId) return false;
            // Allow sample blockIds for preview mode
            if (blockId.startsWith('sample-')) {
                return true;
            }
            const blockText = appState.blockIdToText[blockId];
            return blockText && 
                   blockText !== 'Not Found' && 
                   blockText.trim() !== '';
        }

        function getValueWithOverride(value, blockId) {
            // Return overridden value if exists, otherwise original value
            const override = appState.overrides[blockId];
            return override ? override.overriddenValue : value;
        }

        function extractCoverData() {
            if (!appState.stage2Results) return {};
            const coverChunk = Object.values(appState.stage2Results).find(c => c.chunkType === 'cover');
            if (!coverChunk || !coverChunk.extractions) return {};

            const data = {};
            coverChunk.extractions.forEach(extraction => {
                // Skip if block was not found
                if (!isBlockValid(extraction.blockId)) return;
                
                if (extraction.values) {
                    Object.entries(extraction.values).forEach(([key, value]) => {
                        // Skip "Not Found" values
                        if (!value || value === 'Not Found' || (Array.isArray(value) && value.length === 0)) return;
                        
                        // Get value with override applied
                        const displayValue = getValueWithOverride(value, extraction.blockId);
                        
                        if (key === 'agreementTitle' || key.includes('title')) {
                            data.agreementTitle = displayValue;
                            data.agreementTitleBlockId = extraction.blockId;
                        }
                        if (key === 'borrowers' || key.includes('borrower')) {
                            const borrowerValue = Array.isArray(displayValue) ? displayValue.join(', ') : displayValue;
                            data.borrowers = borrowerValue;
                            data.borrowersBlockId = extraction.blockId;
                        }
                        if (key === 'administrativeAgent' || key.includes('agent')) {
                            data.administrativeAgent = displayValue;
                            data.administrativeAgentBlockId = extraction.blockId;
                        }
                        if (key === 'effectiveDate' || key.includes('date')) {
                            data.effectiveDate = displayValue;
                            data.effectiveDateBlockId = extraction.blockId;
                        }
                    });
                }
            });
            return data;
        }

        function extractDefinitionsData() {
            if (!appState.stage2Results) return { allCommitments: [] };
            const defChunk = Object.values(appState.stage2Results).find(c => c.chunkType === 'definitions');
            if (!defChunk || !defChunk.extractions) return { allCommitments: [] };

            const data = { allCommitments: [], maturityLabel: 'Maturity Date' };
            defChunk.extractions.forEach(extraction => {
                // Skip if block was not found
                if (!isBlockValid(extraction.blockId)) return;
                if (!extraction.values) return;
                
                Object.entries(extraction.values).forEach(([key, value]) => {
                    // Skip "Not Found" values
                    if (value === 'Not Found') return;
                    
                    if (key === 'commitmentAmount') {
                        data.commitmentAmount = getValueWithOverride(value, extraction.blockId);
                        data.commitmentBlockId = extraction.blockId;
                    }
                    if (key === 'dateValue') {
                        const dates = Array.isArray(value) ? value : [value];
                        if (dates.length > 0 && dates[0] !== 'Not Found') {
                            data.maturityDate = getValueWithOverride(dates[0], extraction.blockId);
                            data.maturityBlockId = extraction.blockId;
                        }
                    }
                    // Extract all commitment types separately (don't add them)
                    if (extraction.valueType === 'commitment') {
                        const commitmentLabel = extraction.blockId.replace(/([A-Z])/g, ' $1').trim();
                        const commitmentAmount = extraction.values.commitmentAmount;
                        // Only add if commitment amount is valid
                        if (commitmentAmount && commitmentAmount !== 'Not Found' && commitmentAmount !== 'N/A') {
                            // Check if this commitment blockId already exists to avoid duplicates
                            const existingIndex = data.allCommitments.findIndex(c => c.blockId === extraction.blockId);
                            if (existingIndex === -1) {
                                data.allCommitments.push({
                                    label: commitmentLabel,
                                    amount: getValueWithOverride(commitmentAmount, extraction.blockId),
                                    blockId: extraction.blockId
                                });
                            }
                        }
                    }
                });
            });
            return data;
        }

        function extractCreditsData() {
            if (!appState.stage2Results) return { fees: [], abrLoan: {}, eurodollarLoan: {}, defaultInterest: {} };
            const creditsChunk = Object.values(appState.stage2Results).find(c => c.chunkType === 'credits');
            if (!creditsChunk || !creditsChunk.extractions) return { fees: [], abrLoan: {}, eurodollarLoan: {}, defaultInterest: {} };

            const data = { fees: [], abrLoan: {}, eurodollarLoan: {}, defaultInterest: {}, paymentDefaultGracePeriod: null };
            
            creditsChunk.extractions.forEach(extraction => {
                // Skip if block was not found
                if (!isBlockValid(extraction.blockId)) return;
                if (!extraction.values) return;
                
                const blockId = extraction.blockId;
                
                // Extract fee data
                if (extraction.valueType === 'fee') {
                    // Only add fee if it has valid data
                    const feeRate = extraction.values.feeRate;
                    const feeBase = extraction.values.feeBase;
                    if (feeRate && feeRate !== 'Not Found' && feeRate !== 'N/A') {
                        const fee = {
                            blockId: blockId,
                            feeType: blockId.replace(/([A-Z])/g, ' $1').trim(),
                            feeRate: feeRate,
                            feeBase: feeBase && feeBase !== 'Not Found' ? feeBase : 'N/A',
                            accrualPeriod: extraction.values.accrualPeriod && extraction.values.accrualPeriod !== 'Not Found' ? extraction.values.accrualPeriod : 'N/A',
                            exclusions: extraction.values.exclusions && extraction.values.exclusions !== 'Not Found' ? extraction.values.exclusions : 'N/A',
                            payment: Array.isArray(extraction.values.paymentTiming) 
                                ? extraction.values.paymentTiming.join(', ') 
                                : (extraction.values.paymentTiming && extraction.values.paymentTiming !== 'Not Found' ? extraction.values.paymentTiming : 'N/A')
                        };
                        data.fees.push(fee);
                    }
                }
                
                // Extract interest data
                if (extraction.valueType === 'interest') {
                    const baseRate = extraction.values.baseRate || '';
                    const marginRef = extraction.values.marginReference || '';
                    const formula = Array.isArray(extraction.values.interestRateFormula) 
                        ? extraction.values.interestRateFormula.join('; ') 
                        : (extraction.values.interestRateFormula || '');
                    const paymentTiming = extraction.values.paymentTiming || '';
                    
                    // Only add if baseRate is valid
                    if (baseRate && baseRate !== 'Not Found') {
                        if (baseRate.includes('ABR') || baseRate.includes('Alternate Base Rate')) {
                            data.abrLoan = {
                                blockId: blockId,
                                interestFormula: formula || `${baseRate} + ${marginRef}`,
                                margin: marginRef,
                                paymentTiming: paymentTiming
                            };
                        } else if (baseRate.includes('Eurodollar') || baseRate.includes('LIBO')) {
                            data.eurodollarLoan = {
                                blockId: blockId,
                                interestFormula: formula || `${baseRate} + ${marginRef}`,
                                margin: marginRef,
                                paymentTiming: paymentTiming
                            };
                        } else if (baseRate.includes('Default')) {
                            data.defaultInterest = {
                                blockId: blockId,
                                interestFormula: formula || baseRate,
                                marginReference: marginRef && marginRef !== 'Not Found' ? marginRef : null,
                                paymentTiming: paymentTiming
                            };
                        }
                    }
                }
            });
            
            // Extract margins from definitions chunk (applicableMargin block)
            const defChunk = Object.values(appState.stage2Results).find(c => c.chunkType === 'definitions');
            if (defChunk && defChunk.extractions) {
                defChunk.extractions.forEach(extraction => {
                    // Only use if block is valid
                    if (isBlockValid(extraction.blockId) && extraction.valueType === 'margin' && extraction.values) {
                        // Extract ABR margin
                        if (extraction.values.abrMargin && extraction.values.abrMargin !== 'Not Found') {
                            if (data.abrLoan) {
                                data.abrLoan.abrMargin = extraction.values.abrMargin;
                                data.abrLoan.abrMarginBlockId = extraction.blockId;
                            }
                        }
                        // Extract Eurodollar margin
                        if (extraction.values.eurodollarMargin && extraction.values.eurodollarMargin !== 'Not Found') {
                            if (data.eurodollarLoan) {
                                data.eurodollarLoan.eurodollarMargin = extraction.values.eurodollarMargin;
                                data.eurodollarLoan.eurodollarMarginBlockId = extraction.blockId;
                            }
                        }
                    }
                });
            }
            
            return data;
        }

        function extractRepresentationsData() {
            if (!appState.stage2Results) return {};
            const repChunk = Object.values(appState.stage2Results).find(c => c.chunkType === 'representations');
            if (!repChunk || !repChunk.extractions) return {};

            const data = {};
            repChunk.extractions.forEach(extraction => {
                // Skip if block was not found
                if (!isBlockValid(extraction.blockId)) return;
                
                if (extraction.values && extraction.values.useOfProceeds) {
                    const useOfProceeds = extraction.values.useOfProceeds;
                    // Only add if value is valid
                    if (useOfProceeds && useOfProceeds !== 'Not Found') {
                        data.useOfProceeds = useOfProceeds;
                        data.useOfProceedsBlockId = extraction.blockId;
                    }
                }
            });
            return data;
        }

        function extractCovenantsData() {
            if (!appState.stage2Results) return [];
            const covenantChunk = Object.values(appState.stage2Results).find(c => c.chunkType === 'negative_covenants');
            if (!covenantChunk || !covenantChunk.extractions) return [];

            return covenantChunk.extractions
                .filter(extraction => isBlockValid(extraction.blockId)) // Only include valid blocks
                .map((extraction, idx) => {
                if (!extraction.values) {
                    return null; // No values extracted, filter out
                }
                
                const thresholds = [];
                const thresholdValues = Array.isArray(extraction.values.thresholdValues) 
                    ? extraction.values.thresholdValues 
                    : (extraction.values.thresholdValues ? [extraction.values.thresholdValues] : []);
                const dates = Array.isArray(extraction.values.dates) 
                    ? extraction.values.dates 
                    : (extraction.values.dates ? [extraction.values.dates] : []);
                
                // Filter out invalid threshold values
                const validThresholdValues = thresholdValues.filter(val => 
                    val && val !== 'Not Found' && val !== 'N/A' && val.trim() !== ''
                );
                
                thresholdValues.forEach((val, i) => {
                    // Only add valid threshold values
                    if (val && val !== 'Not Found' && val !== 'N/A' && val.trim() !== '') {
                        // Create unique blockIds for each threshold value and date
                        const valueBlockId = `${extraction.blockId}_thresholdValue_${i}`;
                        const dateBlockId = `${extraction.blockId}_thresholdDate_${i}`;
                        
                        thresholds.push({
                            value: val,
                            date: dates[i] || '',
                            index: i,
                            valueBlockId: valueBlockId, // Unique blockId for this threshold value
                            dateBlockId: dateBlockId    // Unique blockId for this threshold date
                        });
                    }
                });
                
                const operator = extraction.values.operator || '';
                const condition = extraction.values.condition || null;
                
                // Only include covenant if it has at least one meaningful extracted value
                // Check if there are valid thresholds, operator, or condition
                const hasValidThresholds = thresholds.length > 0;
                const hasValidOperator = operator && operator !== 'Not Found' && operator !== 'N/A' && operator.trim() !== '';
                const hasValidCondition = condition && condition !== 'Not Found' && condition !== 'N/A' && condition.trim() !== '';
                
                // If no meaningful values found, return null to filter out
                if (!hasValidThresholds && !hasValidOperator && !hasValidCondition) {
                    return null;
                }
                
                return {
                    blockId: extraction.blockId,
                    title: extraction.blockId.replace(/([A-Z])/g, ' $1').trim(),
                    operator: operator,
                    thresholds: thresholds,
                    condition: condition,
                    gracePeriod: extraction.values.gracePeriod || null
                };
            })
            .filter(covenant => covenant !== null); // Remove null entries
        }

        function extractEventsData() {
            if (!appState.stage2Results) return { events: [], paymentDefaultPrincipalGracePeriod: null, paymentDefaultInterestGracePeriod: null, generalCovenantDefaultGracePeriod: null };
            const eventsChunk = Object.values(appState.stage2Results).find(c => c.chunkType === 'events_of_default');
            if (!eventsChunk || !eventsChunk.extractions) return { events: [], paymentDefaultPrincipalGracePeriod: null, paymentDefaultInterestGracePeriod: null, generalCovenantDefaultGracePeriod: null };

            const events = eventsChunk.extractions
                .filter(extraction => isBlockValid(extraction.blockId)) // Only include valid blocks
                .map(extraction => {
                    if (!extraction.values) {
                        return null; // Will be filtered out
                    }
                    
                    // Handle gracePeriod which might be an array
                    const gracePeriod = Array.isArray(extraction.values.gracePeriod) 
                        ? extraction.values.gracePeriod.join(', ') 
                        : (extraction.values.gracePeriod || 'N/A');
                    
                    return {
                        blockId: extraction.blockId,
                        triggeredBy: extraction.values.defaultCategory || extraction.blockId || 'N/A',
                        defaultType: extraction.values.defaultType || 'N/A',
                        affectedObligation: extraction.values.affectedObligation || 'N/A',
                        automatic: extraction.values.automaticDefault === true || extraction.values.automaticDefault === 'Yes' || extraction.values.automaticDefault === 'yes',
                        category: extraction.values.defaultCategory || 'N/A',
                        gracePeriod: gracePeriod,
                        monetaryThreshold: extraction.values.monetaryThreshold || 'N/A',
                        noticeRequired: extraction.values.noticeRequired || 'N/A'
                    };
                })
                .filter(event => event !== null); // Remove null entries
            
            // Extract specific grace periods for contextual notes
            let paymentDefaultPrincipalGracePeriod = null;
            let paymentDefaultPrincipalGracePeriodBlockId = null;
            let paymentDefaultInterestGracePeriod = null;
            let paymentDefaultInterestGracePeriodBlockId = null;
            let generalCovenantDefaultGracePeriod = null;
            let generalCovenantDefaultGracePeriodBlockId = null;
            
            eventsChunk.extractions.forEach(extraction => {
                if (!isBlockValid(extraction.blockId) || !extraction.values) return;
                
                const gracePeriod = Array.isArray(extraction.values.gracePeriod) 
                    ? extraction.values.gracePeriod[0] 
                    : extraction.values.gracePeriod;
                
                if (gracePeriod && gracePeriod !== 'Not Found' && gracePeriod !== 'N/A') {
                    if (extraction.blockId === 'paymentDefaultPrincipal') {
                        paymentDefaultPrincipalGracePeriod = gracePeriod;
                        paymentDefaultPrincipalGracePeriodBlockId = extraction.blockId;
                    } else if (extraction.blockId === 'paymentDefaultInterest') {
                        paymentDefaultInterestGracePeriod = gracePeriod;
                        paymentDefaultInterestGracePeriodBlockId = extraction.blockId;
                    } else if (extraction.blockId === 'generalCovenantDefault') {
                        generalCovenantDefaultGracePeriod = gracePeriod;
                        generalCovenantDefaultGracePeriodBlockId = extraction.blockId;
                    }
                }
            });
            
            return {
                events: events,
                paymentDefaultPrincipalGracePeriod: paymentDefaultPrincipalGracePeriod,
                paymentDefaultPrincipalGracePeriodBlockId: paymentDefaultPrincipalGracePeriodBlockId,
                paymentDefaultInterestGracePeriod: paymentDefaultInterestGracePeriod,
                paymentDefaultInterestGracePeriodBlockId: paymentDefaultInterestGracePeriodBlockId,
                generalCovenantDefaultGracePeriod: generalCovenantDefaultGracePeriod,
                generalCovenantDefaultGracePeriodBlockId: generalCovenantDefaultGracePeriodBlockId
            };
        }

        // ============================================
        // CLICKABLE VALUES & HIGHLIGHTING
        // ============================================
        function getDisplayValue(value, blockId) {
            // Helper function to get display value (overridden if exists, otherwise original)
            if (!value || value === 'Not Found' || value === 'N/A') {
                return value === 'Not Found' ? 'N/A' : value;
            }
            const valueStr = Array.isArray(value) ? value.join(', ') : String(value);
            const override = appState.overrides[blockId];
            return override ? override.overriddenValue : valueStr;
        }

        function makeClickable(value, identifier, valueLabel) {
            if (!value || value === 'Not Found' || value === 'N/A') {
                return value === 'Not Found' ? 'N/A' : value;
            }
            const valueStr = Array.isArray(value) ? value.join(', ') : String(value);
            // Use identifier as blockId (it should be the actual blockId from extraction)
            const blockId = identifier || null;
            
            // Allow sample data to be clickable for override feature in preview mode
            // Sample blockIds are valid for override functionality
            
            // Check if this value has been overridden
            const override = appState.overrides[blockId];
            const displayValue = override ? override.overriddenValue : valueStr;
            
            // Only make clickable if we have a valid blockId and the block exists
            // Use dataset attribute instead of inline onclick to prevent XSS
            if (blockId && blockId !== 'unknown' && isBlockValid(blockId)) {
                // Escape blockId for use in HTML attribute (though dataset is safer)
                const escapedBlockId = escapeHtml(blockId);
                const escapedLabel = valueLabel ? escapeHtml(valueLabel) : '';
                const escapedValue = escapeHtml(displayValue);
                
                let overrideInfo = '';
                if (override) {
                    const overrideDate = new Date(override.overrideDate).toLocaleDateString();
                    overrideInfo = `<div class="override-info">Modified by ${override.overrideBy} on ${overrideDate}</div>`;
                }
                
                // Check if there are analyst notes for this blockId
                const hasNotes = appState.analystNotes && appState.analystNotes[blockId] && appState.analystNotes[blockId].trim() !== '';
                const stickyNoteIcon = hasNotes ? '<span class="sticky-note-icon" style="margin-left: 6px; font-size: 0.9em; vertical-align: middle; cursor: default; display: inline-block;" title="Analyst has added notes"><span class="material-icons">sticky_note_2</span></span>' : '';
                
                // Return value with info and sticky note icon if notes exist
                return `<span class="clickable-value" data-block-id="${escapedBlockId}" data-value-label="${escapedLabel}">${escapedValue}</span>${stickyNoteIcon}${overrideInfo}`;
            }
            
            // Return non-clickable value if blockId is invalid or missing
            return escapeHtml(valueStr);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function highlightBlock(blockId) {
            // Check if there's an override and if highlighting should be disabled
            const override = appState.overrides[blockId];
            if (override && (override.reason === 'incorrect' || override.reason === 'context')) {
                // Don't highlight if reason is "incorrect" or "context"
                return;
            }
            
            // Find the block text from Stage 1 results
            let blockText = appState.blockIdToText[blockId];
            
            // If override exists and has sourceBlockText, use that for highlighting
            if (override && override.sourceBlockText) {
                blockText = override.sourceBlockText;
            }
            
            if (!blockText || blockText === 'Not Found') {
                // For sample data, still try to highlight even if blockText is short
                if (blockId && blockId.startsWith('sample-')) {
                    // Use a portion of the chunk text for sample data
                    const chunkId = appState.blockIdToChunkId[blockId];
                    if (chunkId && appState.chunkMetadata[chunkId]) {
                        blockText = appState.chunkMetadata[chunkId].text.substring(0, 200);
                    } else {
                        console.log('Block text not found for:', blockId);
                        return;
                    }
                } else {
                    console.log('Block text not found for:', blockId);
                    return;
                }
            }
            
            // Find which chunk this block belongs to and switch to it
            const chunkId = appState.blockIdToChunkId[blockId];
            if (chunkId && appState.chunkMetadata[chunkId]) {
                switchToChunk(chunkId);
            }

            // Find the chunk section in the document viewer
            const viewer = document.getElementById('documentViewer');
            const chunkSection = viewer.querySelector(`.chunk-section[data-chunk-id="${chunkId}"]`);
            if (!chunkSection) {
                console.log('Chunk section not found for:', chunkId);
                return;
            }

            const contentDiv = chunkSection.querySelector('.chunk-section-content');
            if (!contentDiv) {
                console.log('Content div not found in chunk section');
                return;
            }

            // Get the original text (before any highlighting)
            let originalText = contentDiv.textContent || contentDiv.innerText;
            
            // Clean up any existing HTML
            contentDiv.innerHTML = escapeHtml(originalText);

            // Normalize whitespace for matching (handles double spaces, tabs, newlines, etc.)
            function normalizeWhitespace(text) {
                return text
                    .replace(/\s+/g, ' ')  // Replace all whitespace sequences with single space
                    .trim();                // Remove leading/trailing whitespace
            }

            // Normalize both texts for comparison
            const normalizedBlockText = normalizeWhitespace(blockText);
            const normalizedOriginalText = normalizeWhitespace(originalText);
            
            // Use first 100 chars as search anchor (after normalization)
            const searchText = normalizedBlockText.substring(0, Math.min(100, normalizedBlockText.length));
            if (!searchText) return;

            // Find the position in the normalized text
            let normalizedIndex = normalizedOriginalText.indexOf(searchText);
            
            if (normalizedIndex === -1) {
                // Try case-insensitive search
                const lowerText = normalizedOriginalText.toLowerCase();
                const lowerSearch = searchText.toLowerCase();
                normalizedIndex = lowerText.indexOf(lowerSearch);
                
                if (normalizedIndex === -1) {
                    console.log('Could not find block text in document (even after normalization)');
                    console.log('Searching for:', searchText.substring(0, 50) + '...');
                    return;
                }
            }

            // Map normalized position back to original text position
            // This function finds where the normalized match starts in the original text
            const originalStartIndex = findOriginalPosition(originalText, normalizedOriginalText, normalizedIndex);
            const originalEndIndex = findOriginalPosition(
                originalText, 
                normalizedOriginalText, 
                normalizedIndex + normalizedBlockText.length
            );

            // Highlight the full block text in the original text
            if (originalStartIndex !== -1 && originalEndIndex !== -1 && originalStartIndex < originalEndIndex) {
                highlightTextRange(contentDiv, originalStartIndex, originalEndIndex);
            } else {
                // Fallback: use a more lenient search on original text
                const fallbackSearch = blockText.substring(0, Math.min(50, blockText.length)).trim();
                const fallbackIndex = originalText.toLowerCase().indexOf(fallbackSearch.toLowerCase());
                if (fallbackIndex !== -1) {
                    // Estimate end position (approximate, may not be perfect)
                    const estimatedEnd = Math.min(fallbackIndex + blockText.length * 1.2, originalText.length);
                    highlightTextRange(contentDiv, fallbackIndex, estimatedEnd);
                } else {
                    console.log('Could not find block text even with fallback search');
                    return;
                }
            }

            // Scroll to first highlight
            const highlighted = contentDiv.querySelector('.highlighted');
            if (highlighted) {
                highlighted.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        // Helper function to map normalized text position back to original text position
        function findOriginalPosition(originalText, normalizedText, normalizedIndex) {
            if (normalizedIndex <= 0) return 0;
            if (normalizedIndex >= normalizedText.length) return originalText.length;
            
            // Build normalized text from original, tracking positions
            let normalizedPos = 0;
            let originalPos = 0;
            let lastWasWhitespace = false;
            
            while (originalPos < originalText.length && normalizedPos < normalizedIndex) {
                const char = originalText[originalPos];
                const isWhitespace = /\s/.test(char);
                
                if (isWhitespace) {
                    if (!lastWasWhitespace) {
                        // First whitespace in a sequence - count as one space in normalized
                        normalizedPos++;
                    }
                    // Skip additional whitespace characters
                    lastWasWhitespace = true;
                } else {
                    // Non-whitespace character - matches one character in normalized
                    normalizedPos++;
                    lastWasWhitespace = false;
                }
                
                originalPos++;
            }
            
            return originalPos;
        }

        function highlightTextRange(element, startIndex, endIndex) {
            const text = element.textContent;
            if (startIndex < 0 || endIndex > text.length || startIndex >= endIndex) return;

            const before = escapeHtml(text.substring(0, startIndex));
            const match = escapeHtml(text.substring(startIndex, endIndex));
            const after = escapeHtml(text.substring(endIndex));

            element.innerHTML = before + `<span class="highlighted">${match}</span>` + after;
        }

        function escapeRegex(str) {
            return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        function scrollToSection(sectionId) {
            const section = document.getElementById(sectionId);
            if (section) {
                section.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
        }

        // ============================================
        // PAGE NAVIGATION
        // ============================================
        function showPage(pageId) {
            document.querySelectorAll('.page').forEach(page => {
                page.classList.remove('active');
            });
            document.getElementById(pageId).classList.add('active');
            
            // Set up event delegation when dashboard page is shown
            if (pageId === 'dashboardPage') {
                setupClickableValueHandlers();
            }
        }

        // ============================================
        // TOOLBAR ACTIONS
        // ============================================
        document.getElementById('backIcon').addEventListener('click', () => {
            showPage('uploadPage');
            document.getElementById('fileInput').value = '';
        });

        document.getElementById('exportIcon').addEventListener('click', () => {
            // TODO: Implement PDF export
            alert('Export functionality coming soon');
        });
    </script>
</body>
</html>
